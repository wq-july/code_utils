syntax = "proto3";

import "tensorRT.proto";

package CameraConfig;

message Config {
  FeatureConfig feature_config = 1;
  CameraModel camera_model = 2;
}

enum MatcherType {
  HANMING = 0;
  FLANN = 1;
  SUPERGLUE = 2;
};

message FeatureConfig {
  FeatureType feature_type = 1;
  DescriptorType descriptor_type = 2;
  SuperPoint super_point = 3;
  SuperGlue super_glue = 4;
  ORBSLAM orb_slam = 5;
  MatcherType matcher_type = 6;
  FeatureTrackerConfig tracker_config = 7;
}

message SuperPoint {
  int32 image_width = 1;
  int32 image_height = 2;
  int32 max_keypoints = 3;
  double keypoint_threshold = 4;
  int32 remove_borders = 5;
  TensorRTConfig.Config tensor_config = 6;
}

message SuperGlue {
  int32 image_width = 1;
  int32 image_height = 2;
  TensorRTConfig.Config tensor_config = 7;
}

enum FeatureType {
  F_SIFT = 0;
  F_SURF = 1;
  F_ORB = 2;
  F_BRISK = 3;
  F_AKAZE = 4;
  F_SUPERPOINT = 5;
  // TEBLID,
  // FAST_SIFT,
};

enum DescriptorType {
  D_SIFT = 0;
  D_SURF = 1;
  D_ORB = 2;
  D_BRISK = 3;
  D_AKAZE = 4;
  D_SUPERPOINT = 5;
  // FREAK,
  // TEBLID,
};

message FeatureTrackerConfig {
  enum TrackerMothod {
    KLOPTICALFLOW = 0;
    FEATUREMATCH = 1;
  }
  TrackerMothod tracker_method = 1;
  KLOpticalFlowConfig kloptical_flow_config = 2;
  OpenStereoConfig open_stereo_config = 3;
}

message OpenStereoConfig {
  TensorRTConfig.Config tensor_config = 1;
}

message KLOpticalFlowConfig {
  bool enable_klopflow = 1;
  bool reverse_check = 2;
  double pt_err = 3;
  int32 min_tracked_nums = 4;
}


message ORBSLAM {

}


message PinholeConfig {
  double fx = 1;
  double fy = 2;
  double cx = 3;
  double cy = 4;
  double k1 = 5;
  double k2 = 6;
  double p1 = 7;
  double p2 = 8;
  double focal_length = 9;
  int32 iter_times = 10;
  bool enable_cv_undistort = 11;
}

message FishEyeConfig {
  double fx = 1;
  double fy = 2;
  double cx = 3;
  double cy = 4;
  double k1 = 5;
  double k2 = 6;
  double k3 = 7;
  double k4 = 8;
  double focal_length = 9;
  int32 iter_times = 10;
}

message CameraModel {
  enum CameraType {
    PINHOLE = 0;
    // 鱼眼相机
    FISHEYE = 1;
  }
  CameraType type = 1;
  PinholeConfig pinhole_config = 2;
  FishEyeConfig fish_eye_config = 3;
}


message SFMConfig {
  CameraModel camera_model = 1;
  PnpSolverConfig pnp_solver = 2;
  FeatureConfig feature_config = 3;
  bool enable_cv_p2p = 4;
  int32 ransac_iterations = 5;
  double reproj_err_th = 6;
  double sigma = 7;
  enum DecomposeHMethod {
    // Z. Zhang, and A.R. Hanson, “3D Reconstruction based on homography mapping”
    ZHANG = 0;
    // Ezio Malis and Manuel Vargas, "Deeper understanding of the homography decomposition for vision-based control"
    Ezio_Malis = 1;
  }
  DecomposeHMethod decompose_H_method = 8;
}

message PnpSolverConfig {
  enum PnpSolveMethod {
    DLT = 0;
    // BA Gauss-Newton 
    BA = 1;
    // ORB-SLAM3
    EPNP = 2;
    // ORB-SLAM3
    MLPNP = 3;
  }
    
  enum PnpCvMethod {
    /*
      Pose refinement using non-linear Levenberg-Marquardt minimization scheme 
      Initial solution for non-planar "objectPoints" needs at least 6 points and uses the DLT algorithm.
      Initial solution for planar "objectPoints" needs at least 4 points and uses pose from homography decomposition.
    */
    OpenCV_SOLVEPNP_ITERATIVE = 0;
    /*
      EPnP: Efficient Perspective-n-Point Camera Pose Estimation
    */
    OpenCV_SOLVEPNP_EPNP = 1;
    /*
      Complete Solution Classification for the Perspective-Three-Point Problem
    */
    OpenCV_SOLVEPNP_P3P = 2;
    /*
      Broken implementation. Using this flag will fallback to EPnP. A Direct Least-Squares (DLS) Method for PnP [125]
    */
    OpenCV_SOLVEPNP_DLS = 3;
    /*
      Broken implementation. Using this flag will fallback to EPnP. Exhaustive Linearization for Robust Camera Pose and Focal Length Estimation
    */
    OpenCV_SOLVEPNP_UPNP = 4;
    /*
      An Efficient Algebraic Solution to the Perspective-Three-Point Problem
    */
    OpenCV_SOLVEPNP_AP3P = 5;
    /*
      Infinitesimal Plane-Based Pose Estimation. Object points must be coplanar.
    */
    OpenCV_SOLVEPNP_IPPE = 6;
    /*
      Infinitesimal Plane-Based Pose Estimation. 
      This is a special case suitable for marker pose estimation.
      4 coplanar object points must be defined in the following order:
      point 0: [-squareLength / 2, squareLength / 2, 0]
      point 1: [ squareLength / 2, squareLength / 2, 0]
      point 2: [ squareLength / 2, -squareLength / 2, 0]
      point 3: [-squareLength / 2, -squareLength / 2, 0]
    */
    OpenCV_SOLVEPNP_IPPE_SQUARE = 7;
    /*
      SQPnP: A Consistently Fast and Globally OptimalSolution to the Perspective-n-Point Problem.
    */
    OpenCV_SOLVEPNP_SQPNP = 8;
  }

  bool enable_cv_pnp = 1;
  PnpSolveMethod pnp_solve_method = 2;
  PnpCvMethod pnp_cv_method = 3;
  int32 max_iterations = 4;
}