syntax = "proto3";

import "tensorRT.proto";

package CameraConfig;

message Config {
  FeatureConfig feature_config = 1;
  CameraModel camera_model = 2;
}

enum MatcherType {
  HANMING = 0;
  FLANN = 1;
  SUPERGLUE = 2;
};

message FeatureConfig {
  FeatureType feature_type = 1;
  DescriptorType descriptor_type = 2;
  SuperPoint super_point = 3;
  SuperGlue super_glue = 4;
  ORBSLAM orb_slam = 5;
  MatcherType matcher_type = 6;
  FeatureTrackerConfig tracker_config = 7;
}

message SuperPoint {
  int32 image_width = 1;
  int32 image_height = 2;
  int32 max_keypoints = 3;
  double keypoint_threshold = 4;
  int32 remove_borders = 5;
  TensorRTConfig.Config tensor_config = 6;
}

message SuperGlue {
  int32 image_width = 1;
  int32 image_height = 2;
  TensorRTConfig.Config tensor_config = 7;
}

enum FeatureType {
  F_SIFT = 0;
  F_SURF = 1;
  F_ORB = 2;
  F_BRISK = 3;
  F_AKAZE = 4;
  F_SUPERPOINT = 5;
  // TEBLID,
  // FAST_SIFT,
};

enum DescriptorType {
  D_SIFT = 0;
  D_SURF = 1;
  D_ORB = 2;
  D_BRISK = 3;
  D_AKAZE = 4;
  D_SUPERPOINT = 5;
  // FREAK,
  // TEBLID,
};

message FeatureTrackerConfig {
  enum TrackerMothod {
    KLOPTICALFLOW = 0;
    FEATUREMATCH = 1;
  }
  TrackerMothod tracker_method = 1;
  KLOpticalFlowConfig kloptical_flow_config = 2;
  OpenStereoConfig open_stereo_config = 3;
}

message OpenStereoConfig {
  TensorRTConfig.Config tensor_config = 1;
}

message KLOpticalFlowConfig {
  bool reverse_check = 1;
  double pt_err = 2;
  int32 min_tracked_nums = 3;
}


message ORBSLAM {

}

enum DistortMethod {
  OpenCV = 0;
  VINSMONO = 1;
}

message PinholeConfig {
  double fx = 1;
  double fy = 2;
  double cx = 3;
  double cy = 4;
  double k1 = 5;
  double k2 = 6;
  double p1 = 7;
  double p2 = 8;
  int32 iter_times = 9;
  DistortMethod distort_method = 10;
}

message FishEyeConfig {
  double fx = 1;
  double fy = 2;
  double cx = 3;
  double cy = 4;
  double k1 = 5;
  double k2 = 6;
  double k3 = 7;
  double k4 = 8;
  int32 iter_times = 9;
}

message CameraModel {
  enum CameraType {
    PINHOLE = 0;
    // 鱼眼相机
    FISHEYE = 1;
  }
  CameraType type = 1;
  PinholeConfig pinhole_config = 2;
  FishEyeConfig fish_eye_config = 3;
}


message SFM {
  
}

message PnpSolverConfig {
  enum PnpSolveMethod {
    DLT = 0;
    // P3P，利用三角形相似转化为ICP 
    P3P = 1;
    // ORB-SLAM3
    EPNP = 2;
    // ORB-SLAM3
    MLPNP = 3;
    /*
      Pose refinement using non-linear Levenberg-Marquardt minimization scheme 
      Initial solution for non-planar "objectPoints" needs at least 6 points and uses the DLT algorithm.
      Initial solution for planar "objectPoints" needs at least 4 points and uses pose from homography decomposition.
    */
    OpenCV_SOLVEPNP_ITERATIVE = 4;
    /*
      EPnP: Efficient Perspective-n-Point Camera Pose Estimation
    */
    OpenCV_SOLVEPNP_EPNP = 5;
    /*
      Complete Solution Classification for the Perspective-Three-Point Problem
    */
    OpenCV_SOLVEPNP_P3P = 6;
    /*
      Broken implementation. Using this flag will fallback to EPnP. A Direct Least-Squares (DLS) Method for PnP [125]
    */
    OpenCV_SOLVEPNP_DLS = 7;
    /*
      Broken implementation. Using this flag will fallback to EPnP. Exhaustive Linearization for Robust Camera Pose and Focal Length Estimation
    */
    OpenCV_SOLVEPNP_UPNP = 8;
    /*
      An Efficient Algebraic Solution to the Perspective-Three-Point Problem
    */
    OpenCV_SOLVEPNP_AP3P = 9;
    /*
      Infinitesimal Plane-Based Pose Estimation. Object points must be coplanar.
    */
    OpenCV_SOLVEPNP_IPPE = 10;
    /*
      Infinitesimal Plane-Based Pose Estimation. 
      This is a special case suitable for marker pose estimation.
      4 coplanar object points must be defined in the following order:
      point 0: [-squareLength / 2, squareLength / 2, 0]
      point 1: [ squareLength / 2, squareLength / 2, 0]
      point 2: [ squareLength / 2, -squareLength / 2, 0]
      point 3: [-squareLength / 2, -squareLength / 2, 0]
    */
    OpenCV_SOLVEPNP_IPPE_SQUARE = 11;
    /*
      SQPnP: A Consistently Fast and Globally OptimalSolution to the Perspective-n-Point Problem.
    */
    OpenCV_SOLVEPNP_SQPNP = 12;
  }
  
  PnpSolveMethod pnp_solve_method = 1;

}