// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: camera.proto

#ifndef PROTOBUF_INCLUDED_camera_2eproto
#define PROTOBUF_INCLUDED_camera_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorRT.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_camera_2eproto 

namespace protobuf_camera_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_camera_2eproto
namespace CameraConfig {
class CameraModel;
class CameraModelDefaultTypeInternal;
extern CameraModelDefaultTypeInternal _CameraModel_default_instance_;
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class FeatureConfig;
class FeatureConfigDefaultTypeInternal;
extern FeatureConfigDefaultTypeInternal _FeatureConfig_default_instance_;
class FeatureTrackerConfig;
class FeatureTrackerConfigDefaultTypeInternal;
extern FeatureTrackerConfigDefaultTypeInternal _FeatureTrackerConfig_default_instance_;
class KLOpticalFlowConfig;
class KLOpticalFlowConfigDefaultTypeInternal;
extern KLOpticalFlowConfigDefaultTypeInternal _KLOpticalFlowConfig_default_instance_;
class ORBSLAM;
class ORBSLAMDefaultTypeInternal;
extern ORBSLAMDefaultTypeInternal _ORBSLAM_default_instance_;
class OpenStereoConfig;
class OpenStereoConfigDefaultTypeInternal;
extern OpenStereoConfigDefaultTypeInternal _OpenStereoConfig_default_instance_;
class SuperGlue;
class SuperGlueDefaultTypeInternal;
extern SuperGlueDefaultTypeInternal _SuperGlue_default_instance_;
class SuperPoint;
class SuperPointDefaultTypeInternal;
extern SuperPointDefaultTypeInternal _SuperPoint_default_instance_;
}  // namespace CameraConfig
namespace google {
namespace protobuf {
template<> ::CameraConfig::CameraModel* Arena::CreateMaybeMessage<::CameraConfig::CameraModel>(Arena*);
template<> ::CameraConfig::Config* Arena::CreateMaybeMessage<::CameraConfig::Config>(Arena*);
template<> ::CameraConfig::FeatureConfig* Arena::CreateMaybeMessage<::CameraConfig::FeatureConfig>(Arena*);
template<> ::CameraConfig::FeatureTrackerConfig* Arena::CreateMaybeMessage<::CameraConfig::FeatureTrackerConfig>(Arena*);
template<> ::CameraConfig::KLOpticalFlowConfig* Arena::CreateMaybeMessage<::CameraConfig::KLOpticalFlowConfig>(Arena*);
template<> ::CameraConfig::ORBSLAM* Arena::CreateMaybeMessage<::CameraConfig::ORBSLAM>(Arena*);
template<> ::CameraConfig::OpenStereoConfig* Arena::CreateMaybeMessage<::CameraConfig::OpenStereoConfig>(Arena*);
template<> ::CameraConfig::SuperGlue* Arena::CreateMaybeMessage<::CameraConfig::SuperGlue>(Arena*);
template<> ::CameraConfig::SuperPoint* Arena::CreateMaybeMessage<::CameraConfig::SuperPoint>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace CameraConfig {

enum FeatureType {
  F_SIFT = 0,
  F_SURF = 1,
  F_ORB = 2,
  F_BRISK = 3,
  F_AKAZE = 4,
  F_SUPERPOINT = 5,
  FeatureType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FeatureType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FeatureType_IsValid(int value);
const FeatureType FeatureType_MIN = F_SIFT;
const FeatureType FeatureType_MAX = F_SUPERPOINT;
const int FeatureType_ARRAYSIZE = FeatureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FeatureType_descriptor();
inline const ::std::string& FeatureType_Name(FeatureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FeatureType_descriptor(), value);
}
inline bool FeatureType_Parse(
    const ::std::string& name, FeatureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FeatureType>(
    FeatureType_descriptor(), name, value);
}
enum DescriptorType {
  D_SIFT = 0,
  D_SURF = 1,
  D_ORB = 2,
  D_BRISK = 3,
  D_AKAZE = 4,
  D_SUPERPOINT = 5,
  DescriptorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DescriptorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DescriptorType_IsValid(int value);
const DescriptorType DescriptorType_MIN = D_SIFT;
const DescriptorType DescriptorType_MAX = D_SUPERPOINT;
const int DescriptorType_ARRAYSIZE = DescriptorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DescriptorType_descriptor();
inline const ::std::string& DescriptorType_Name(DescriptorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DescriptorType_descriptor(), value);
}
inline bool DescriptorType_Parse(
    const ::std::string& name, DescriptorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DescriptorType>(
    DescriptorType_descriptor(), name, value);
}
enum MatcherType {
  HANMING = 0,
  FLANN = 1,
  SUPERGLUE = 2,
  MatcherType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MatcherType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MatcherType_IsValid(int value);
const MatcherType MatcherType_MIN = HANMING;
const MatcherType MatcherType_MAX = SUPERGLUE;
const int MatcherType_ARRAYSIZE = MatcherType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MatcherType_descriptor();
inline const ::std::string& MatcherType_Name(MatcherType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MatcherType_descriptor(), value);
}
inline bool MatcherType_Parse(
    const ::std::string& name, MatcherType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MatcherType>(
    MatcherType_descriptor(), name, value);
}
enum TrackerMothod {
  KLOPTICALFLOW = 0,
  TrackerMothod_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrackerMothod_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrackerMothod_IsValid(int value);
const TrackerMothod TrackerMothod_MIN = KLOPTICALFLOW;
const TrackerMothod TrackerMothod_MAX = KLOPTICALFLOW;
const int TrackerMothod_ARRAYSIZE = TrackerMothod_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrackerMothod_descriptor();
inline const ::std::string& TrackerMothod_Name(TrackerMothod value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrackerMothod_descriptor(), value);
}
inline bool TrackerMothod_Parse(
    const ::std::string& name, TrackerMothod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrackerMothod>(
    TrackerMothod_descriptor(), name, value);
}
// ===================================================================

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(NULL);
  }

  Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CameraConfig.FeatureConfig feature_config = 1;
  bool has_feature_config() const;
  void clear_feature_config();
  static const int kFeatureConfigFieldNumber = 1;
  private:
  const ::CameraConfig::FeatureConfig& _internal_feature_config() const;
  public:
  const ::CameraConfig::FeatureConfig& feature_config() const;
  ::CameraConfig::FeatureConfig* release_feature_config();
  ::CameraConfig::FeatureConfig* mutable_feature_config();
  void set_allocated_feature_config(::CameraConfig::FeatureConfig* feature_config);

  // .CameraConfig.CameraModel camera_model = 2;
  bool has_camera_model() const;
  void clear_camera_model();
  static const int kCameraModelFieldNumber = 2;
  private:
  const ::CameraConfig::CameraModel& _internal_camera_model() const;
  public:
  const ::CameraConfig::CameraModel& camera_model() const;
  ::CameraConfig::CameraModel* release_camera_model();
  ::CameraConfig::CameraModel* mutable_camera_model();
  void set_allocated_camera_model(::CameraConfig::CameraModel* camera_model);

  // @@protoc_insertion_point(class_scope:CameraConfig.Config)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CameraConfig::FeatureConfig* feature_config_;
  ::CameraConfig::CameraModel* camera_model_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FeatureConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.FeatureConfig) */ {
 public:
  FeatureConfig();
  virtual ~FeatureConfig();

  FeatureConfig(const FeatureConfig& from);

  inline FeatureConfig& operator=(const FeatureConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeatureConfig(FeatureConfig&& from) noexcept
    : FeatureConfig() {
    *this = ::std::move(from);
  }

  inline FeatureConfig& operator=(FeatureConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureConfig* internal_default_instance() {
    return reinterpret_cast<const FeatureConfig*>(
               &_FeatureConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FeatureConfig* other);
  friend void swap(FeatureConfig& a, FeatureConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeatureConfig* New() const final {
    return CreateMaybeMessage<FeatureConfig>(NULL);
  }

  FeatureConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FeatureConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FeatureConfig& from);
  void MergeFrom(const FeatureConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CameraConfig.SuperPoint super_point = 3;
  bool has_super_point() const;
  void clear_super_point();
  static const int kSuperPointFieldNumber = 3;
  private:
  const ::CameraConfig::SuperPoint& _internal_super_point() const;
  public:
  const ::CameraConfig::SuperPoint& super_point() const;
  ::CameraConfig::SuperPoint* release_super_point();
  ::CameraConfig::SuperPoint* mutable_super_point();
  void set_allocated_super_point(::CameraConfig::SuperPoint* super_point);

  // .CameraConfig.SuperGlue super_glue = 4;
  bool has_super_glue() const;
  void clear_super_glue();
  static const int kSuperGlueFieldNumber = 4;
  private:
  const ::CameraConfig::SuperGlue& _internal_super_glue() const;
  public:
  const ::CameraConfig::SuperGlue& super_glue() const;
  ::CameraConfig::SuperGlue* release_super_glue();
  ::CameraConfig::SuperGlue* mutable_super_glue();
  void set_allocated_super_glue(::CameraConfig::SuperGlue* super_glue);

  // .CameraConfig.ORBSLAM orb_slam = 5;
  bool has_orb_slam() const;
  void clear_orb_slam();
  static const int kOrbSlamFieldNumber = 5;
  private:
  const ::CameraConfig::ORBSLAM& _internal_orb_slam() const;
  public:
  const ::CameraConfig::ORBSLAM& orb_slam() const;
  ::CameraConfig::ORBSLAM* release_orb_slam();
  ::CameraConfig::ORBSLAM* mutable_orb_slam();
  void set_allocated_orb_slam(::CameraConfig::ORBSLAM* orb_slam);

  // .CameraConfig.FeatureTrackerConfig tracker_config = 7;
  bool has_tracker_config() const;
  void clear_tracker_config();
  static const int kTrackerConfigFieldNumber = 7;
  private:
  const ::CameraConfig::FeatureTrackerConfig& _internal_tracker_config() const;
  public:
  const ::CameraConfig::FeatureTrackerConfig& tracker_config() const;
  ::CameraConfig::FeatureTrackerConfig* release_tracker_config();
  ::CameraConfig::FeatureTrackerConfig* mutable_tracker_config();
  void set_allocated_tracker_config(::CameraConfig::FeatureTrackerConfig* tracker_config);

  // .CameraConfig.FeatureType feature_type = 1;
  void clear_feature_type();
  static const int kFeatureTypeFieldNumber = 1;
  ::CameraConfig::FeatureType feature_type() const;
  void set_feature_type(::CameraConfig::FeatureType value);

  // .CameraConfig.DescriptorType descriptor_type = 2;
  void clear_descriptor_type();
  static const int kDescriptorTypeFieldNumber = 2;
  ::CameraConfig::DescriptorType descriptor_type() const;
  void set_descriptor_type(::CameraConfig::DescriptorType value);

  // .CameraConfig.MatcherType matcher_type = 6;
  void clear_matcher_type();
  static const int kMatcherTypeFieldNumber = 6;
  ::CameraConfig::MatcherType matcher_type() const;
  void set_matcher_type(::CameraConfig::MatcherType value);

  // @@protoc_insertion_point(class_scope:CameraConfig.FeatureConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CameraConfig::SuperPoint* super_point_;
  ::CameraConfig::SuperGlue* super_glue_;
  ::CameraConfig::ORBSLAM* orb_slam_;
  ::CameraConfig::FeatureTrackerConfig* tracker_config_;
  int feature_type_;
  int descriptor_type_;
  int matcher_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SuperPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.SuperPoint) */ {
 public:
  SuperPoint();
  virtual ~SuperPoint();

  SuperPoint(const SuperPoint& from);

  inline SuperPoint& operator=(const SuperPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SuperPoint(SuperPoint&& from) noexcept
    : SuperPoint() {
    *this = ::std::move(from);
  }

  inline SuperPoint& operator=(SuperPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SuperPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SuperPoint* internal_default_instance() {
    return reinterpret_cast<const SuperPoint*>(
               &_SuperPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SuperPoint* other);
  friend void swap(SuperPoint& a, SuperPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SuperPoint* New() const final {
    return CreateMaybeMessage<SuperPoint>(NULL);
  }

  SuperPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SuperPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SuperPoint& from);
  void MergeFrom(const SuperPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuperPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TensorRTConfig.Config tensor_config = 6;
  bool has_tensor_config() const;
  void clear_tensor_config();
  static const int kTensorConfigFieldNumber = 6;
  private:
  const ::TensorRTConfig::Config& _internal_tensor_config() const;
  public:
  const ::TensorRTConfig::Config& tensor_config() const;
  ::TensorRTConfig::Config* release_tensor_config();
  ::TensorRTConfig::Config* mutable_tensor_config();
  void set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config);

  // int32 image_width = 1;
  void clear_image_width();
  static const int kImageWidthFieldNumber = 1;
  ::google::protobuf::int32 image_width() const;
  void set_image_width(::google::protobuf::int32 value);

  // int32 image_height = 2;
  void clear_image_height();
  static const int kImageHeightFieldNumber = 2;
  ::google::protobuf::int32 image_height() const;
  void set_image_height(::google::protobuf::int32 value);

  // double keypoint_threshold = 4;
  void clear_keypoint_threshold();
  static const int kKeypointThresholdFieldNumber = 4;
  double keypoint_threshold() const;
  void set_keypoint_threshold(double value);

  // int32 max_keypoints = 3;
  void clear_max_keypoints();
  static const int kMaxKeypointsFieldNumber = 3;
  ::google::protobuf::int32 max_keypoints() const;
  void set_max_keypoints(::google::protobuf::int32 value);

  // int32 remove_borders = 5;
  void clear_remove_borders();
  static const int kRemoveBordersFieldNumber = 5;
  ::google::protobuf::int32 remove_borders() const;
  void set_remove_borders(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CameraConfig.SuperPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::TensorRTConfig::Config* tensor_config_;
  ::google::protobuf::int32 image_width_;
  ::google::protobuf::int32 image_height_;
  double keypoint_threshold_;
  ::google::protobuf::int32 max_keypoints_;
  ::google::protobuf::int32 remove_borders_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SuperGlue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.SuperGlue) */ {
 public:
  SuperGlue();
  virtual ~SuperGlue();

  SuperGlue(const SuperGlue& from);

  inline SuperGlue& operator=(const SuperGlue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SuperGlue(SuperGlue&& from) noexcept
    : SuperGlue() {
    *this = ::std::move(from);
  }

  inline SuperGlue& operator=(SuperGlue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SuperGlue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SuperGlue* internal_default_instance() {
    return reinterpret_cast<const SuperGlue*>(
               &_SuperGlue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SuperGlue* other);
  friend void swap(SuperGlue& a, SuperGlue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SuperGlue* New() const final {
    return CreateMaybeMessage<SuperGlue>(NULL);
  }

  SuperGlue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SuperGlue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SuperGlue& from);
  void MergeFrom(const SuperGlue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuperGlue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TensorRTConfig.Config tensor_config = 7;
  bool has_tensor_config() const;
  void clear_tensor_config();
  static const int kTensorConfigFieldNumber = 7;
  private:
  const ::TensorRTConfig::Config& _internal_tensor_config() const;
  public:
  const ::TensorRTConfig::Config& tensor_config() const;
  ::TensorRTConfig::Config* release_tensor_config();
  ::TensorRTConfig::Config* mutable_tensor_config();
  void set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config);

  // int32 image_width = 1;
  void clear_image_width();
  static const int kImageWidthFieldNumber = 1;
  ::google::protobuf::int32 image_width() const;
  void set_image_width(::google::protobuf::int32 value);

  // int32 image_height = 2;
  void clear_image_height();
  static const int kImageHeightFieldNumber = 2;
  ::google::protobuf::int32 image_height() const;
  void set_image_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CameraConfig.SuperGlue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::TensorRTConfig::Config* tensor_config_;
  ::google::protobuf::int32 image_width_;
  ::google::protobuf::int32 image_height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FeatureTrackerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.FeatureTrackerConfig) */ {
 public:
  FeatureTrackerConfig();
  virtual ~FeatureTrackerConfig();

  FeatureTrackerConfig(const FeatureTrackerConfig& from);

  inline FeatureTrackerConfig& operator=(const FeatureTrackerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeatureTrackerConfig(FeatureTrackerConfig&& from) noexcept
    : FeatureTrackerConfig() {
    *this = ::std::move(from);
  }

  inline FeatureTrackerConfig& operator=(FeatureTrackerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureTrackerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureTrackerConfig* internal_default_instance() {
    return reinterpret_cast<const FeatureTrackerConfig*>(
               &_FeatureTrackerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FeatureTrackerConfig* other);
  friend void swap(FeatureTrackerConfig& a, FeatureTrackerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeatureTrackerConfig* New() const final {
    return CreateMaybeMessage<FeatureTrackerConfig>(NULL);
  }

  FeatureTrackerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FeatureTrackerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FeatureTrackerConfig& from);
  void MergeFrom(const FeatureTrackerConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureTrackerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CameraConfig.KLOpticalFlowConfig kloptical_flow_config = 2;
  bool has_kloptical_flow_config() const;
  void clear_kloptical_flow_config();
  static const int kKlopticalFlowConfigFieldNumber = 2;
  private:
  const ::CameraConfig::KLOpticalFlowConfig& _internal_kloptical_flow_config() const;
  public:
  const ::CameraConfig::KLOpticalFlowConfig& kloptical_flow_config() const;
  ::CameraConfig::KLOpticalFlowConfig* release_kloptical_flow_config();
  ::CameraConfig::KLOpticalFlowConfig* mutable_kloptical_flow_config();
  void set_allocated_kloptical_flow_config(::CameraConfig::KLOpticalFlowConfig* kloptical_flow_config);

  // .CameraConfig.OpenStereoConfig open_stereo_config = 3;
  bool has_open_stereo_config() const;
  void clear_open_stereo_config();
  static const int kOpenStereoConfigFieldNumber = 3;
  private:
  const ::CameraConfig::OpenStereoConfig& _internal_open_stereo_config() const;
  public:
  const ::CameraConfig::OpenStereoConfig& open_stereo_config() const;
  ::CameraConfig::OpenStereoConfig* release_open_stereo_config();
  ::CameraConfig::OpenStereoConfig* mutable_open_stereo_config();
  void set_allocated_open_stereo_config(::CameraConfig::OpenStereoConfig* open_stereo_config);

  // .CameraConfig.TrackerMothod tracker_method = 1;
  void clear_tracker_method();
  static const int kTrackerMethodFieldNumber = 1;
  ::CameraConfig::TrackerMothod tracker_method() const;
  void set_tracker_method(::CameraConfig::TrackerMothod value);

  // @@protoc_insertion_point(class_scope:CameraConfig.FeatureTrackerConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CameraConfig::KLOpticalFlowConfig* kloptical_flow_config_;
  ::CameraConfig::OpenStereoConfig* open_stereo_config_;
  int tracker_method_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KLOpticalFlowConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.KLOpticalFlowConfig) */ {
 public:
  KLOpticalFlowConfig();
  virtual ~KLOpticalFlowConfig();

  KLOpticalFlowConfig(const KLOpticalFlowConfig& from);

  inline KLOpticalFlowConfig& operator=(const KLOpticalFlowConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KLOpticalFlowConfig(KLOpticalFlowConfig&& from) noexcept
    : KLOpticalFlowConfig() {
    *this = ::std::move(from);
  }

  inline KLOpticalFlowConfig& operator=(KLOpticalFlowConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KLOpticalFlowConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KLOpticalFlowConfig* internal_default_instance() {
    return reinterpret_cast<const KLOpticalFlowConfig*>(
               &_KLOpticalFlowConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(KLOpticalFlowConfig* other);
  friend void swap(KLOpticalFlowConfig& a, KLOpticalFlowConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KLOpticalFlowConfig* New() const final {
    return CreateMaybeMessage<KLOpticalFlowConfig>(NULL);
  }

  KLOpticalFlowConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KLOpticalFlowConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KLOpticalFlowConfig& from);
  void MergeFrom(const KLOpticalFlowConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KLOpticalFlowConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double pt_err = 2;
  void clear_pt_err();
  static const int kPtErrFieldNumber = 2;
  double pt_err() const;
  void set_pt_err(double value);

  // bool reverse_check = 1;
  void clear_reverse_check();
  static const int kReverseCheckFieldNumber = 1;
  bool reverse_check() const;
  void set_reverse_check(bool value);

  // int32 min_tracked_nums = 3;
  void clear_min_tracked_nums();
  static const int kMinTrackedNumsFieldNumber = 3;
  ::google::protobuf::int32 min_tracked_nums() const;
  void set_min_tracked_nums(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CameraConfig.KLOpticalFlowConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double pt_err_;
  bool reverse_check_;
  ::google::protobuf::int32 min_tracked_nums_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpenStereoConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.OpenStereoConfig) */ {
 public:
  OpenStereoConfig();
  virtual ~OpenStereoConfig();

  OpenStereoConfig(const OpenStereoConfig& from);

  inline OpenStereoConfig& operator=(const OpenStereoConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenStereoConfig(OpenStereoConfig&& from) noexcept
    : OpenStereoConfig() {
    *this = ::std::move(from);
  }

  inline OpenStereoConfig& operator=(OpenStereoConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenStereoConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenStereoConfig* internal_default_instance() {
    return reinterpret_cast<const OpenStereoConfig*>(
               &_OpenStereoConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(OpenStereoConfig* other);
  friend void swap(OpenStereoConfig& a, OpenStereoConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenStereoConfig* New() const final {
    return CreateMaybeMessage<OpenStereoConfig>(NULL);
  }

  OpenStereoConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OpenStereoConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OpenStereoConfig& from);
  void MergeFrom(const OpenStereoConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenStereoConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TensorRTConfig.Config tensor_config = 1;
  bool has_tensor_config() const;
  void clear_tensor_config();
  static const int kTensorConfigFieldNumber = 1;
  private:
  const ::TensorRTConfig::Config& _internal_tensor_config() const;
  public:
  const ::TensorRTConfig::Config& tensor_config() const;
  ::TensorRTConfig::Config* release_tensor_config();
  ::TensorRTConfig::Config* mutable_tensor_config();
  void set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config);

  // @@protoc_insertion_point(class_scope:CameraConfig.OpenStereoConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::TensorRTConfig::Config* tensor_config_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ORBSLAM : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.ORBSLAM) */ {
 public:
  ORBSLAM();
  virtual ~ORBSLAM();

  ORBSLAM(const ORBSLAM& from);

  inline ORBSLAM& operator=(const ORBSLAM& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ORBSLAM(ORBSLAM&& from) noexcept
    : ORBSLAM() {
    *this = ::std::move(from);
  }

  inline ORBSLAM& operator=(ORBSLAM&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ORBSLAM& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ORBSLAM* internal_default_instance() {
    return reinterpret_cast<const ORBSLAM*>(
               &_ORBSLAM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ORBSLAM* other);
  friend void swap(ORBSLAM& a, ORBSLAM& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ORBSLAM* New() const final {
    return CreateMaybeMessage<ORBSLAM>(NULL);
  }

  ORBSLAM* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ORBSLAM>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ORBSLAM& from);
  void MergeFrom(const ORBSLAM& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ORBSLAM* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CameraConfig.ORBSLAM)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CameraModel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.CameraModel) */ {
 public:
  CameraModel();
  virtual ~CameraModel();

  CameraModel(const CameraModel& from);

  inline CameraModel& operator=(const CameraModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraModel(CameraModel&& from) noexcept
    : CameraModel() {
    *this = ::std::move(from);
  }

  inline CameraModel& operator=(CameraModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraModel* internal_default_instance() {
    return reinterpret_cast<const CameraModel*>(
               &_CameraModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CameraModel* other);
  friend void swap(CameraModel& a, CameraModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraModel* New() const final {
    return CreateMaybeMessage<CameraModel>(NULL);
  }

  CameraModel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CameraModel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CameraModel& from);
  void MergeFrom(const CameraModel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CameraConfig.CameraModel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Config

// .CameraConfig.FeatureConfig feature_config = 1;
inline bool Config::has_feature_config() const {
  return this != internal_default_instance() && feature_config_ != NULL;
}
inline void Config::clear_feature_config() {
  if (GetArenaNoVirtual() == NULL && feature_config_ != NULL) {
    delete feature_config_;
  }
  feature_config_ = NULL;
}
inline const ::CameraConfig::FeatureConfig& Config::_internal_feature_config() const {
  return *feature_config_;
}
inline const ::CameraConfig::FeatureConfig& Config::feature_config() const {
  const ::CameraConfig::FeatureConfig* p = feature_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.Config.feature_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::FeatureConfig*>(
      &::CameraConfig::_FeatureConfig_default_instance_);
}
inline ::CameraConfig::FeatureConfig* Config::release_feature_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.Config.feature_config)
  
  ::CameraConfig::FeatureConfig* temp = feature_config_;
  feature_config_ = NULL;
  return temp;
}
inline ::CameraConfig::FeatureConfig* Config::mutable_feature_config() {
  
  if (feature_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::FeatureConfig>(GetArenaNoVirtual());
    feature_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.Config.feature_config)
  return feature_config_;
}
inline void Config::set_allocated_feature_config(::CameraConfig::FeatureConfig* feature_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete feature_config_;
  }
  if (feature_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature_config, submessage_arena);
    }
    
  } else {
    
  }
  feature_config_ = feature_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.Config.feature_config)
}

// .CameraConfig.CameraModel camera_model = 2;
inline bool Config::has_camera_model() const {
  return this != internal_default_instance() && camera_model_ != NULL;
}
inline void Config::clear_camera_model() {
  if (GetArenaNoVirtual() == NULL && camera_model_ != NULL) {
    delete camera_model_;
  }
  camera_model_ = NULL;
}
inline const ::CameraConfig::CameraModel& Config::_internal_camera_model() const {
  return *camera_model_;
}
inline const ::CameraConfig::CameraModel& Config::camera_model() const {
  const ::CameraConfig::CameraModel* p = camera_model_;
  // @@protoc_insertion_point(field_get:CameraConfig.Config.camera_model)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::CameraModel*>(
      &::CameraConfig::_CameraModel_default_instance_);
}
inline ::CameraConfig::CameraModel* Config::release_camera_model() {
  // @@protoc_insertion_point(field_release:CameraConfig.Config.camera_model)
  
  ::CameraConfig::CameraModel* temp = camera_model_;
  camera_model_ = NULL;
  return temp;
}
inline ::CameraConfig::CameraModel* Config::mutable_camera_model() {
  
  if (camera_model_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::CameraModel>(GetArenaNoVirtual());
    camera_model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.Config.camera_model)
  return camera_model_;
}
inline void Config::set_allocated_camera_model(::CameraConfig::CameraModel* camera_model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete camera_model_;
  }
  if (camera_model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      camera_model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, camera_model, submessage_arena);
    }
    
  } else {
    
  }
  camera_model_ = camera_model;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.Config.camera_model)
}

// -------------------------------------------------------------------

// FeatureConfig

// .CameraConfig.FeatureType feature_type = 1;
inline void FeatureConfig::clear_feature_type() {
  feature_type_ = 0;
}
inline ::CameraConfig::FeatureType FeatureConfig::feature_type() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.feature_type)
  return static_cast< ::CameraConfig::FeatureType >(feature_type_);
}
inline void FeatureConfig::set_feature_type(::CameraConfig::FeatureType value) {
  
  feature_type_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FeatureConfig.feature_type)
}

// .CameraConfig.DescriptorType descriptor_type = 2;
inline void FeatureConfig::clear_descriptor_type() {
  descriptor_type_ = 0;
}
inline ::CameraConfig::DescriptorType FeatureConfig::descriptor_type() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.descriptor_type)
  return static_cast< ::CameraConfig::DescriptorType >(descriptor_type_);
}
inline void FeatureConfig::set_descriptor_type(::CameraConfig::DescriptorType value) {
  
  descriptor_type_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FeatureConfig.descriptor_type)
}

// .CameraConfig.SuperPoint super_point = 3;
inline bool FeatureConfig::has_super_point() const {
  return this != internal_default_instance() && super_point_ != NULL;
}
inline void FeatureConfig::clear_super_point() {
  if (GetArenaNoVirtual() == NULL && super_point_ != NULL) {
    delete super_point_;
  }
  super_point_ = NULL;
}
inline const ::CameraConfig::SuperPoint& FeatureConfig::_internal_super_point() const {
  return *super_point_;
}
inline const ::CameraConfig::SuperPoint& FeatureConfig::super_point() const {
  const ::CameraConfig::SuperPoint* p = super_point_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.super_point)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::SuperPoint*>(
      &::CameraConfig::_SuperPoint_default_instance_);
}
inline ::CameraConfig::SuperPoint* FeatureConfig::release_super_point() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureConfig.super_point)
  
  ::CameraConfig::SuperPoint* temp = super_point_;
  super_point_ = NULL;
  return temp;
}
inline ::CameraConfig::SuperPoint* FeatureConfig::mutable_super_point() {
  
  if (super_point_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::SuperPoint>(GetArenaNoVirtual());
    super_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureConfig.super_point)
  return super_point_;
}
inline void FeatureConfig::set_allocated_super_point(::CameraConfig::SuperPoint* super_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete super_point_;
  }
  if (super_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      super_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, super_point, submessage_arena);
    }
    
  } else {
    
  }
  super_point_ = super_point;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureConfig.super_point)
}

// .CameraConfig.SuperGlue super_glue = 4;
inline bool FeatureConfig::has_super_glue() const {
  return this != internal_default_instance() && super_glue_ != NULL;
}
inline void FeatureConfig::clear_super_glue() {
  if (GetArenaNoVirtual() == NULL && super_glue_ != NULL) {
    delete super_glue_;
  }
  super_glue_ = NULL;
}
inline const ::CameraConfig::SuperGlue& FeatureConfig::_internal_super_glue() const {
  return *super_glue_;
}
inline const ::CameraConfig::SuperGlue& FeatureConfig::super_glue() const {
  const ::CameraConfig::SuperGlue* p = super_glue_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.super_glue)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::SuperGlue*>(
      &::CameraConfig::_SuperGlue_default_instance_);
}
inline ::CameraConfig::SuperGlue* FeatureConfig::release_super_glue() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureConfig.super_glue)
  
  ::CameraConfig::SuperGlue* temp = super_glue_;
  super_glue_ = NULL;
  return temp;
}
inline ::CameraConfig::SuperGlue* FeatureConfig::mutable_super_glue() {
  
  if (super_glue_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::SuperGlue>(GetArenaNoVirtual());
    super_glue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureConfig.super_glue)
  return super_glue_;
}
inline void FeatureConfig::set_allocated_super_glue(::CameraConfig::SuperGlue* super_glue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete super_glue_;
  }
  if (super_glue) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      super_glue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, super_glue, submessage_arena);
    }
    
  } else {
    
  }
  super_glue_ = super_glue;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureConfig.super_glue)
}

// .CameraConfig.ORBSLAM orb_slam = 5;
inline bool FeatureConfig::has_orb_slam() const {
  return this != internal_default_instance() && orb_slam_ != NULL;
}
inline void FeatureConfig::clear_orb_slam() {
  if (GetArenaNoVirtual() == NULL && orb_slam_ != NULL) {
    delete orb_slam_;
  }
  orb_slam_ = NULL;
}
inline const ::CameraConfig::ORBSLAM& FeatureConfig::_internal_orb_slam() const {
  return *orb_slam_;
}
inline const ::CameraConfig::ORBSLAM& FeatureConfig::orb_slam() const {
  const ::CameraConfig::ORBSLAM* p = orb_slam_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.orb_slam)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::ORBSLAM*>(
      &::CameraConfig::_ORBSLAM_default_instance_);
}
inline ::CameraConfig::ORBSLAM* FeatureConfig::release_orb_slam() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureConfig.orb_slam)
  
  ::CameraConfig::ORBSLAM* temp = orb_slam_;
  orb_slam_ = NULL;
  return temp;
}
inline ::CameraConfig::ORBSLAM* FeatureConfig::mutable_orb_slam() {
  
  if (orb_slam_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::ORBSLAM>(GetArenaNoVirtual());
    orb_slam_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureConfig.orb_slam)
  return orb_slam_;
}
inline void FeatureConfig::set_allocated_orb_slam(::CameraConfig::ORBSLAM* orb_slam) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orb_slam_;
  }
  if (orb_slam) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orb_slam = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orb_slam, submessage_arena);
    }
    
  } else {
    
  }
  orb_slam_ = orb_slam;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureConfig.orb_slam)
}

// .CameraConfig.MatcherType matcher_type = 6;
inline void FeatureConfig::clear_matcher_type() {
  matcher_type_ = 0;
}
inline ::CameraConfig::MatcherType FeatureConfig::matcher_type() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.matcher_type)
  return static_cast< ::CameraConfig::MatcherType >(matcher_type_);
}
inline void FeatureConfig::set_matcher_type(::CameraConfig::MatcherType value) {
  
  matcher_type_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FeatureConfig.matcher_type)
}

// .CameraConfig.FeatureTrackerConfig tracker_config = 7;
inline bool FeatureConfig::has_tracker_config() const {
  return this != internal_default_instance() && tracker_config_ != NULL;
}
inline void FeatureConfig::clear_tracker_config() {
  if (GetArenaNoVirtual() == NULL && tracker_config_ != NULL) {
    delete tracker_config_;
  }
  tracker_config_ = NULL;
}
inline const ::CameraConfig::FeatureTrackerConfig& FeatureConfig::_internal_tracker_config() const {
  return *tracker_config_;
}
inline const ::CameraConfig::FeatureTrackerConfig& FeatureConfig::tracker_config() const {
  const ::CameraConfig::FeatureTrackerConfig* p = tracker_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.tracker_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::FeatureTrackerConfig*>(
      &::CameraConfig::_FeatureTrackerConfig_default_instance_);
}
inline ::CameraConfig::FeatureTrackerConfig* FeatureConfig::release_tracker_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureConfig.tracker_config)
  
  ::CameraConfig::FeatureTrackerConfig* temp = tracker_config_;
  tracker_config_ = NULL;
  return temp;
}
inline ::CameraConfig::FeatureTrackerConfig* FeatureConfig::mutable_tracker_config() {
  
  if (tracker_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::FeatureTrackerConfig>(GetArenaNoVirtual());
    tracker_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureConfig.tracker_config)
  return tracker_config_;
}
inline void FeatureConfig::set_allocated_tracker_config(::CameraConfig::FeatureTrackerConfig* tracker_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tracker_config_;
  }
  if (tracker_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tracker_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tracker_config, submessage_arena);
    }
    
  } else {
    
  }
  tracker_config_ = tracker_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureConfig.tracker_config)
}

// -------------------------------------------------------------------

// SuperPoint

// int32 image_width = 1;
inline void SuperPoint::clear_image_width() {
  image_width_ = 0;
}
inline ::google::protobuf::int32 SuperPoint::image_width() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.image_width)
  return image_width_;
}
inline void SuperPoint::set_image_width(::google::protobuf::int32 value) {
  
  image_width_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperPoint.image_width)
}

// int32 image_height = 2;
inline void SuperPoint::clear_image_height() {
  image_height_ = 0;
}
inline ::google::protobuf::int32 SuperPoint::image_height() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.image_height)
  return image_height_;
}
inline void SuperPoint::set_image_height(::google::protobuf::int32 value) {
  
  image_height_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperPoint.image_height)
}

// int32 max_keypoints = 3;
inline void SuperPoint::clear_max_keypoints() {
  max_keypoints_ = 0;
}
inline ::google::protobuf::int32 SuperPoint::max_keypoints() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.max_keypoints)
  return max_keypoints_;
}
inline void SuperPoint::set_max_keypoints(::google::protobuf::int32 value) {
  
  max_keypoints_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperPoint.max_keypoints)
}

// double keypoint_threshold = 4;
inline void SuperPoint::clear_keypoint_threshold() {
  keypoint_threshold_ = 0;
}
inline double SuperPoint::keypoint_threshold() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.keypoint_threshold)
  return keypoint_threshold_;
}
inline void SuperPoint::set_keypoint_threshold(double value) {
  
  keypoint_threshold_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperPoint.keypoint_threshold)
}

// int32 remove_borders = 5;
inline void SuperPoint::clear_remove_borders() {
  remove_borders_ = 0;
}
inline ::google::protobuf::int32 SuperPoint::remove_borders() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.remove_borders)
  return remove_borders_;
}
inline void SuperPoint::set_remove_borders(::google::protobuf::int32 value) {
  
  remove_borders_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperPoint.remove_borders)
}

// .TensorRTConfig.Config tensor_config = 6;
inline bool SuperPoint::has_tensor_config() const {
  return this != internal_default_instance() && tensor_config_ != NULL;
}
inline const ::TensorRTConfig::Config& SuperPoint::_internal_tensor_config() const {
  return *tensor_config_;
}
inline const ::TensorRTConfig::Config& SuperPoint::tensor_config() const {
  const ::TensorRTConfig::Config* p = tensor_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.tensor_config)
  return p != NULL ? *p : *reinterpret_cast<const ::TensorRTConfig::Config*>(
      &::TensorRTConfig::_Config_default_instance_);
}
inline ::TensorRTConfig::Config* SuperPoint::release_tensor_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.SuperPoint.tensor_config)
  
  ::TensorRTConfig::Config* temp = tensor_config_;
  tensor_config_ = NULL;
  return temp;
}
inline ::TensorRTConfig::Config* SuperPoint::mutable_tensor_config() {
  
  if (tensor_config_ == NULL) {
    auto* p = CreateMaybeMessage<::TensorRTConfig::Config>(GetArenaNoVirtual());
    tensor_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.SuperPoint.tensor_config)
  return tensor_config_;
}
inline void SuperPoint::set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tensor_config_);
  }
  if (tensor_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tensor_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tensor_config, submessage_arena);
    }
    
  } else {
    
  }
  tensor_config_ = tensor_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.SuperPoint.tensor_config)
}

// -------------------------------------------------------------------

// SuperGlue

// int32 image_width = 1;
inline void SuperGlue::clear_image_width() {
  image_width_ = 0;
}
inline ::google::protobuf::int32 SuperGlue::image_width() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperGlue.image_width)
  return image_width_;
}
inline void SuperGlue::set_image_width(::google::protobuf::int32 value) {
  
  image_width_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperGlue.image_width)
}

// int32 image_height = 2;
inline void SuperGlue::clear_image_height() {
  image_height_ = 0;
}
inline ::google::protobuf::int32 SuperGlue::image_height() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperGlue.image_height)
  return image_height_;
}
inline void SuperGlue::set_image_height(::google::protobuf::int32 value) {
  
  image_height_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperGlue.image_height)
}

// .TensorRTConfig.Config tensor_config = 7;
inline bool SuperGlue::has_tensor_config() const {
  return this != internal_default_instance() && tensor_config_ != NULL;
}
inline const ::TensorRTConfig::Config& SuperGlue::_internal_tensor_config() const {
  return *tensor_config_;
}
inline const ::TensorRTConfig::Config& SuperGlue::tensor_config() const {
  const ::TensorRTConfig::Config* p = tensor_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.SuperGlue.tensor_config)
  return p != NULL ? *p : *reinterpret_cast<const ::TensorRTConfig::Config*>(
      &::TensorRTConfig::_Config_default_instance_);
}
inline ::TensorRTConfig::Config* SuperGlue::release_tensor_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.SuperGlue.tensor_config)
  
  ::TensorRTConfig::Config* temp = tensor_config_;
  tensor_config_ = NULL;
  return temp;
}
inline ::TensorRTConfig::Config* SuperGlue::mutable_tensor_config() {
  
  if (tensor_config_ == NULL) {
    auto* p = CreateMaybeMessage<::TensorRTConfig::Config>(GetArenaNoVirtual());
    tensor_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.SuperGlue.tensor_config)
  return tensor_config_;
}
inline void SuperGlue::set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tensor_config_);
  }
  if (tensor_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tensor_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tensor_config, submessage_arena);
    }
    
  } else {
    
  }
  tensor_config_ = tensor_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.SuperGlue.tensor_config)
}

// -------------------------------------------------------------------

// FeatureTrackerConfig

// .CameraConfig.TrackerMothod tracker_method = 1;
inline void FeatureTrackerConfig::clear_tracker_method() {
  tracker_method_ = 0;
}
inline ::CameraConfig::TrackerMothod FeatureTrackerConfig::tracker_method() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureTrackerConfig.tracker_method)
  return static_cast< ::CameraConfig::TrackerMothod >(tracker_method_);
}
inline void FeatureTrackerConfig::set_tracker_method(::CameraConfig::TrackerMothod value) {
  
  tracker_method_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FeatureTrackerConfig.tracker_method)
}

// .CameraConfig.KLOpticalFlowConfig kloptical_flow_config = 2;
inline bool FeatureTrackerConfig::has_kloptical_flow_config() const {
  return this != internal_default_instance() && kloptical_flow_config_ != NULL;
}
inline void FeatureTrackerConfig::clear_kloptical_flow_config() {
  if (GetArenaNoVirtual() == NULL && kloptical_flow_config_ != NULL) {
    delete kloptical_flow_config_;
  }
  kloptical_flow_config_ = NULL;
}
inline const ::CameraConfig::KLOpticalFlowConfig& FeatureTrackerConfig::_internal_kloptical_flow_config() const {
  return *kloptical_flow_config_;
}
inline const ::CameraConfig::KLOpticalFlowConfig& FeatureTrackerConfig::kloptical_flow_config() const {
  const ::CameraConfig::KLOpticalFlowConfig* p = kloptical_flow_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureTrackerConfig.kloptical_flow_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::KLOpticalFlowConfig*>(
      &::CameraConfig::_KLOpticalFlowConfig_default_instance_);
}
inline ::CameraConfig::KLOpticalFlowConfig* FeatureTrackerConfig::release_kloptical_flow_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureTrackerConfig.kloptical_flow_config)
  
  ::CameraConfig::KLOpticalFlowConfig* temp = kloptical_flow_config_;
  kloptical_flow_config_ = NULL;
  return temp;
}
inline ::CameraConfig::KLOpticalFlowConfig* FeatureTrackerConfig::mutable_kloptical_flow_config() {
  
  if (kloptical_flow_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::KLOpticalFlowConfig>(GetArenaNoVirtual());
    kloptical_flow_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureTrackerConfig.kloptical_flow_config)
  return kloptical_flow_config_;
}
inline void FeatureTrackerConfig::set_allocated_kloptical_flow_config(::CameraConfig::KLOpticalFlowConfig* kloptical_flow_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kloptical_flow_config_;
  }
  if (kloptical_flow_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kloptical_flow_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kloptical_flow_config, submessage_arena);
    }
    
  } else {
    
  }
  kloptical_flow_config_ = kloptical_flow_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureTrackerConfig.kloptical_flow_config)
}

// .CameraConfig.OpenStereoConfig open_stereo_config = 3;
inline bool FeatureTrackerConfig::has_open_stereo_config() const {
  return this != internal_default_instance() && open_stereo_config_ != NULL;
}
inline void FeatureTrackerConfig::clear_open_stereo_config() {
  if (GetArenaNoVirtual() == NULL && open_stereo_config_ != NULL) {
    delete open_stereo_config_;
  }
  open_stereo_config_ = NULL;
}
inline const ::CameraConfig::OpenStereoConfig& FeatureTrackerConfig::_internal_open_stereo_config() const {
  return *open_stereo_config_;
}
inline const ::CameraConfig::OpenStereoConfig& FeatureTrackerConfig::open_stereo_config() const {
  const ::CameraConfig::OpenStereoConfig* p = open_stereo_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureTrackerConfig.open_stereo_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::OpenStereoConfig*>(
      &::CameraConfig::_OpenStereoConfig_default_instance_);
}
inline ::CameraConfig::OpenStereoConfig* FeatureTrackerConfig::release_open_stereo_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureTrackerConfig.open_stereo_config)
  
  ::CameraConfig::OpenStereoConfig* temp = open_stereo_config_;
  open_stereo_config_ = NULL;
  return temp;
}
inline ::CameraConfig::OpenStereoConfig* FeatureTrackerConfig::mutable_open_stereo_config() {
  
  if (open_stereo_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::OpenStereoConfig>(GetArenaNoVirtual());
    open_stereo_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureTrackerConfig.open_stereo_config)
  return open_stereo_config_;
}
inline void FeatureTrackerConfig::set_allocated_open_stereo_config(::CameraConfig::OpenStereoConfig* open_stereo_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete open_stereo_config_;
  }
  if (open_stereo_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      open_stereo_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, open_stereo_config, submessage_arena);
    }
    
  } else {
    
  }
  open_stereo_config_ = open_stereo_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureTrackerConfig.open_stereo_config)
}

// -------------------------------------------------------------------

// KLOpticalFlowConfig

// bool reverse_check = 1;
inline void KLOpticalFlowConfig::clear_reverse_check() {
  reverse_check_ = false;
}
inline bool KLOpticalFlowConfig::reverse_check() const {
  // @@protoc_insertion_point(field_get:CameraConfig.KLOpticalFlowConfig.reverse_check)
  return reverse_check_;
}
inline void KLOpticalFlowConfig::set_reverse_check(bool value) {
  
  reverse_check_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.KLOpticalFlowConfig.reverse_check)
}

// double pt_err = 2;
inline void KLOpticalFlowConfig::clear_pt_err() {
  pt_err_ = 0;
}
inline double KLOpticalFlowConfig::pt_err() const {
  // @@protoc_insertion_point(field_get:CameraConfig.KLOpticalFlowConfig.pt_err)
  return pt_err_;
}
inline void KLOpticalFlowConfig::set_pt_err(double value) {
  
  pt_err_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.KLOpticalFlowConfig.pt_err)
}

// int32 min_tracked_nums = 3;
inline void KLOpticalFlowConfig::clear_min_tracked_nums() {
  min_tracked_nums_ = 0;
}
inline ::google::protobuf::int32 KLOpticalFlowConfig::min_tracked_nums() const {
  // @@protoc_insertion_point(field_get:CameraConfig.KLOpticalFlowConfig.min_tracked_nums)
  return min_tracked_nums_;
}
inline void KLOpticalFlowConfig::set_min_tracked_nums(::google::protobuf::int32 value) {
  
  min_tracked_nums_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.KLOpticalFlowConfig.min_tracked_nums)
}

// -------------------------------------------------------------------

// OpenStereoConfig

// .TensorRTConfig.Config tensor_config = 1;
inline bool OpenStereoConfig::has_tensor_config() const {
  return this != internal_default_instance() && tensor_config_ != NULL;
}
inline const ::TensorRTConfig::Config& OpenStereoConfig::_internal_tensor_config() const {
  return *tensor_config_;
}
inline const ::TensorRTConfig::Config& OpenStereoConfig::tensor_config() const {
  const ::TensorRTConfig::Config* p = tensor_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.OpenStereoConfig.tensor_config)
  return p != NULL ? *p : *reinterpret_cast<const ::TensorRTConfig::Config*>(
      &::TensorRTConfig::_Config_default_instance_);
}
inline ::TensorRTConfig::Config* OpenStereoConfig::release_tensor_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.OpenStereoConfig.tensor_config)
  
  ::TensorRTConfig::Config* temp = tensor_config_;
  tensor_config_ = NULL;
  return temp;
}
inline ::TensorRTConfig::Config* OpenStereoConfig::mutable_tensor_config() {
  
  if (tensor_config_ == NULL) {
    auto* p = CreateMaybeMessage<::TensorRTConfig::Config>(GetArenaNoVirtual());
    tensor_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.OpenStereoConfig.tensor_config)
  return tensor_config_;
}
inline void OpenStereoConfig::set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tensor_config_);
  }
  if (tensor_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tensor_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tensor_config, submessage_arena);
    }
    
  } else {
    
  }
  tensor_config_ = tensor_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.OpenStereoConfig.tensor_config)
}

// -------------------------------------------------------------------

// ORBSLAM

// -------------------------------------------------------------------

// CameraModel

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace CameraConfig

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CameraConfig::FeatureType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::FeatureType>() {
  return ::CameraConfig::FeatureType_descriptor();
}
template <> struct is_proto_enum< ::CameraConfig::DescriptorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::DescriptorType>() {
  return ::CameraConfig::DescriptorType_descriptor();
}
template <> struct is_proto_enum< ::CameraConfig::MatcherType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::MatcherType>() {
  return ::CameraConfig::MatcherType_descriptor();
}
template <> struct is_proto_enum< ::CameraConfig::TrackerMothod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::TrackerMothod>() {
  return ::CameraConfig::TrackerMothod_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_camera_2eproto
