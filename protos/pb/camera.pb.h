// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: camera.proto

#ifndef PROTOBUF_INCLUDED_camera_2eproto
#define PROTOBUF_INCLUDED_camera_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorRT.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_camera_2eproto 

namespace protobuf_camera_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_camera_2eproto
namespace CameraConfig {
class CameraModel;
class CameraModelDefaultTypeInternal;
extern CameraModelDefaultTypeInternal _CameraModel_default_instance_;
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class FeatureConfig;
class FeatureConfigDefaultTypeInternal;
extern FeatureConfigDefaultTypeInternal _FeatureConfig_default_instance_;
class FeatureTrackerConfig;
class FeatureTrackerConfigDefaultTypeInternal;
extern FeatureTrackerConfigDefaultTypeInternal _FeatureTrackerConfig_default_instance_;
class FishEyeConfig;
class FishEyeConfigDefaultTypeInternal;
extern FishEyeConfigDefaultTypeInternal _FishEyeConfig_default_instance_;
class KLOpticalFlowConfig;
class KLOpticalFlowConfigDefaultTypeInternal;
extern KLOpticalFlowConfigDefaultTypeInternal _KLOpticalFlowConfig_default_instance_;
class ORBSLAM;
class ORBSLAMDefaultTypeInternal;
extern ORBSLAMDefaultTypeInternal _ORBSLAM_default_instance_;
class OpenStereoConfig;
class OpenStereoConfigDefaultTypeInternal;
extern OpenStereoConfigDefaultTypeInternal _OpenStereoConfig_default_instance_;
class PinholeConfig;
class PinholeConfigDefaultTypeInternal;
extern PinholeConfigDefaultTypeInternal _PinholeConfig_default_instance_;
class PnpSolverConfig;
class PnpSolverConfigDefaultTypeInternal;
extern PnpSolverConfigDefaultTypeInternal _PnpSolverConfig_default_instance_;
class SFMConfig;
class SFMConfigDefaultTypeInternal;
extern SFMConfigDefaultTypeInternal _SFMConfig_default_instance_;
class SuperGlue;
class SuperGlueDefaultTypeInternal;
extern SuperGlueDefaultTypeInternal _SuperGlue_default_instance_;
class SuperPoint;
class SuperPointDefaultTypeInternal;
extern SuperPointDefaultTypeInternal _SuperPoint_default_instance_;
}  // namespace CameraConfig
namespace google {
namespace protobuf {
template<> ::CameraConfig::CameraModel* Arena::CreateMaybeMessage<::CameraConfig::CameraModel>(Arena*);
template<> ::CameraConfig::Config* Arena::CreateMaybeMessage<::CameraConfig::Config>(Arena*);
template<> ::CameraConfig::FeatureConfig* Arena::CreateMaybeMessage<::CameraConfig::FeatureConfig>(Arena*);
template<> ::CameraConfig::FeatureTrackerConfig* Arena::CreateMaybeMessage<::CameraConfig::FeatureTrackerConfig>(Arena*);
template<> ::CameraConfig::FishEyeConfig* Arena::CreateMaybeMessage<::CameraConfig::FishEyeConfig>(Arena*);
template<> ::CameraConfig::KLOpticalFlowConfig* Arena::CreateMaybeMessage<::CameraConfig::KLOpticalFlowConfig>(Arena*);
template<> ::CameraConfig::ORBSLAM* Arena::CreateMaybeMessage<::CameraConfig::ORBSLAM>(Arena*);
template<> ::CameraConfig::OpenStereoConfig* Arena::CreateMaybeMessage<::CameraConfig::OpenStereoConfig>(Arena*);
template<> ::CameraConfig::PinholeConfig* Arena::CreateMaybeMessage<::CameraConfig::PinholeConfig>(Arena*);
template<> ::CameraConfig::PnpSolverConfig* Arena::CreateMaybeMessage<::CameraConfig::PnpSolverConfig>(Arena*);
template<> ::CameraConfig::SFMConfig* Arena::CreateMaybeMessage<::CameraConfig::SFMConfig>(Arena*);
template<> ::CameraConfig::SuperGlue* Arena::CreateMaybeMessage<::CameraConfig::SuperGlue>(Arena*);
template<> ::CameraConfig::SuperPoint* Arena::CreateMaybeMessage<::CameraConfig::SuperPoint>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace CameraConfig {

enum FeatureTrackerConfig_TrackerMothod {
  FeatureTrackerConfig_TrackerMothod_KLOPTICALFLOW = 0,
  FeatureTrackerConfig_TrackerMothod_FEATUREMATCH = 1,
  FeatureTrackerConfig_TrackerMothod_FeatureTrackerConfig_TrackerMothod_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FeatureTrackerConfig_TrackerMothod_FeatureTrackerConfig_TrackerMothod_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FeatureTrackerConfig_TrackerMothod_IsValid(int value);
const FeatureTrackerConfig_TrackerMothod FeatureTrackerConfig_TrackerMothod_TrackerMothod_MIN = FeatureTrackerConfig_TrackerMothod_KLOPTICALFLOW;
const FeatureTrackerConfig_TrackerMothod FeatureTrackerConfig_TrackerMothod_TrackerMothod_MAX = FeatureTrackerConfig_TrackerMothod_FEATUREMATCH;
const int FeatureTrackerConfig_TrackerMothod_TrackerMothod_ARRAYSIZE = FeatureTrackerConfig_TrackerMothod_TrackerMothod_MAX + 1;

const ::google::protobuf::EnumDescriptor* FeatureTrackerConfig_TrackerMothod_descriptor();
inline const ::std::string& FeatureTrackerConfig_TrackerMothod_Name(FeatureTrackerConfig_TrackerMothod value) {
  return ::google::protobuf::internal::NameOfEnum(
    FeatureTrackerConfig_TrackerMothod_descriptor(), value);
}
inline bool FeatureTrackerConfig_TrackerMothod_Parse(
    const ::std::string& name, FeatureTrackerConfig_TrackerMothod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FeatureTrackerConfig_TrackerMothod>(
    FeatureTrackerConfig_TrackerMothod_descriptor(), name, value);
}
enum CameraModel_CameraType {
  CameraModel_CameraType_PINHOLE = 0,
  CameraModel_CameraType_FISHEYE = 1,
  CameraModel_CameraType_CameraModel_CameraType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CameraModel_CameraType_CameraModel_CameraType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CameraModel_CameraType_IsValid(int value);
const CameraModel_CameraType CameraModel_CameraType_CameraType_MIN = CameraModel_CameraType_PINHOLE;
const CameraModel_CameraType CameraModel_CameraType_CameraType_MAX = CameraModel_CameraType_FISHEYE;
const int CameraModel_CameraType_CameraType_ARRAYSIZE = CameraModel_CameraType_CameraType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CameraModel_CameraType_descriptor();
inline const ::std::string& CameraModel_CameraType_Name(CameraModel_CameraType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CameraModel_CameraType_descriptor(), value);
}
inline bool CameraModel_CameraType_Parse(
    const ::std::string& name, CameraModel_CameraType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraModel_CameraType>(
    CameraModel_CameraType_descriptor(), name, value);
}
enum SFMConfig_DecomposeHMethod {
  SFMConfig_DecomposeHMethod_ZHANG = 0,
  SFMConfig_DecomposeHMethod_Ezio_Malis = 1,
  SFMConfig_DecomposeHMethod_SFMConfig_DecomposeHMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SFMConfig_DecomposeHMethod_SFMConfig_DecomposeHMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SFMConfig_DecomposeHMethod_IsValid(int value);
const SFMConfig_DecomposeHMethod SFMConfig_DecomposeHMethod_DecomposeHMethod_MIN = SFMConfig_DecomposeHMethod_ZHANG;
const SFMConfig_DecomposeHMethod SFMConfig_DecomposeHMethod_DecomposeHMethod_MAX = SFMConfig_DecomposeHMethod_Ezio_Malis;
const int SFMConfig_DecomposeHMethod_DecomposeHMethod_ARRAYSIZE = SFMConfig_DecomposeHMethod_DecomposeHMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* SFMConfig_DecomposeHMethod_descriptor();
inline const ::std::string& SFMConfig_DecomposeHMethod_Name(SFMConfig_DecomposeHMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    SFMConfig_DecomposeHMethod_descriptor(), value);
}
inline bool SFMConfig_DecomposeHMethod_Parse(
    const ::std::string& name, SFMConfig_DecomposeHMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SFMConfig_DecomposeHMethod>(
    SFMConfig_DecomposeHMethod_descriptor(), name, value);
}
enum PnpSolverConfig_PnpSolveMethod {
  PnpSolverConfig_PnpSolveMethod_DLT = 0,
  PnpSolverConfig_PnpSolveMethod_BA = 1,
  PnpSolverConfig_PnpSolveMethod_EPNP = 2,
  PnpSolverConfig_PnpSolveMethod_MLPNP = 3,
  PnpSolverConfig_PnpSolveMethod_PnpSolverConfig_PnpSolveMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PnpSolverConfig_PnpSolveMethod_PnpSolverConfig_PnpSolveMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PnpSolverConfig_PnpSolveMethod_IsValid(int value);
const PnpSolverConfig_PnpSolveMethod PnpSolverConfig_PnpSolveMethod_PnpSolveMethod_MIN = PnpSolverConfig_PnpSolveMethod_DLT;
const PnpSolverConfig_PnpSolveMethod PnpSolverConfig_PnpSolveMethod_PnpSolveMethod_MAX = PnpSolverConfig_PnpSolveMethod_MLPNP;
const int PnpSolverConfig_PnpSolveMethod_PnpSolveMethod_ARRAYSIZE = PnpSolverConfig_PnpSolveMethod_PnpSolveMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* PnpSolverConfig_PnpSolveMethod_descriptor();
inline const ::std::string& PnpSolverConfig_PnpSolveMethod_Name(PnpSolverConfig_PnpSolveMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    PnpSolverConfig_PnpSolveMethod_descriptor(), value);
}
inline bool PnpSolverConfig_PnpSolveMethod_Parse(
    const ::std::string& name, PnpSolverConfig_PnpSolveMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PnpSolverConfig_PnpSolveMethod>(
    PnpSolverConfig_PnpSolveMethod_descriptor(), name, value);
}
enum PnpSolverConfig_PnpCvMethod {
  PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_ITERATIVE = 0,
  PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_EPNP = 1,
  PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_P3P = 2,
  PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_DLS = 3,
  PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_UPNP = 4,
  PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_AP3P = 5,
  PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_IPPE = 6,
  PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_IPPE_SQUARE = 7,
  PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_SQPNP = 8,
  PnpSolverConfig_PnpCvMethod_PnpSolverConfig_PnpCvMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PnpSolverConfig_PnpCvMethod_PnpSolverConfig_PnpCvMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PnpSolverConfig_PnpCvMethod_IsValid(int value);
const PnpSolverConfig_PnpCvMethod PnpSolverConfig_PnpCvMethod_PnpCvMethod_MIN = PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_ITERATIVE;
const PnpSolverConfig_PnpCvMethod PnpSolverConfig_PnpCvMethod_PnpCvMethod_MAX = PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_SQPNP;
const int PnpSolverConfig_PnpCvMethod_PnpCvMethod_ARRAYSIZE = PnpSolverConfig_PnpCvMethod_PnpCvMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* PnpSolverConfig_PnpCvMethod_descriptor();
inline const ::std::string& PnpSolverConfig_PnpCvMethod_Name(PnpSolverConfig_PnpCvMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    PnpSolverConfig_PnpCvMethod_descriptor(), value);
}
inline bool PnpSolverConfig_PnpCvMethod_Parse(
    const ::std::string& name, PnpSolverConfig_PnpCvMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PnpSolverConfig_PnpCvMethod>(
    PnpSolverConfig_PnpCvMethod_descriptor(), name, value);
}
enum MatcherType {
  HANMING = 0,
  FLANN = 1,
  SUPERGLUE = 2,
  MatcherType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MatcherType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MatcherType_IsValid(int value);
const MatcherType MatcherType_MIN = HANMING;
const MatcherType MatcherType_MAX = SUPERGLUE;
const int MatcherType_ARRAYSIZE = MatcherType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MatcherType_descriptor();
inline const ::std::string& MatcherType_Name(MatcherType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MatcherType_descriptor(), value);
}
inline bool MatcherType_Parse(
    const ::std::string& name, MatcherType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MatcherType>(
    MatcherType_descriptor(), name, value);
}
enum FeatureType {
  F_SIFT = 0,
  F_SURF = 1,
  F_ORB = 2,
  F_BRISK = 3,
  F_AKAZE = 4,
  F_SUPERPOINT = 5,
  FeatureType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FeatureType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FeatureType_IsValid(int value);
const FeatureType FeatureType_MIN = F_SIFT;
const FeatureType FeatureType_MAX = F_SUPERPOINT;
const int FeatureType_ARRAYSIZE = FeatureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FeatureType_descriptor();
inline const ::std::string& FeatureType_Name(FeatureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FeatureType_descriptor(), value);
}
inline bool FeatureType_Parse(
    const ::std::string& name, FeatureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FeatureType>(
    FeatureType_descriptor(), name, value);
}
enum DescriptorType {
  D_SIFT = 0,
  D_SURF = 1,
  D_ORB = 2,
  D_BRISK = 3,
  D_AKAZE = 4,
  D_SUPERPOINT = 5,
  DescriptorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DescriptorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DescriptorType_IsValid(int value);
const DescriptorType DescriptorType_MIN = D_SIFT;
const DescriptorType DescriptorType_MAX = D_SUPERPOINT;
const int DescriptorType_ARRAYSIZE = DescriptorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DescriptorType_descriptor();
inline const ::std::string& DescriptorType_Name(DescriptorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DescriptorType_descriptor(), value);
}
inline bool DescriptorType_Parse(
    const ::std::string& name, DescriptorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DescriptorType>(
    DescriptorType_descriptor(), name, value);
}
// ===================================================================

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(NULL);
  }

  Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CameraConfig.FeatureConfig feature_config = 1;
  bool has_feature_config() const;
  void clear_feature_config();
  static const int kFeatureConfigFieldNumber = 1;
  private:
  const ::CameraConfig::FeatureConfig& _internal_feature_config() const;
  public:
  const ::CameraConfig::FeatureConfig& feature_config() const;
  ::CameraConfig::FeatureConfig* release_feature_config();
  ::CameraConfig::FeatureConfig* mutable_feature_config();
  void set_allocated_feature_config(::CameraConfig::FeatureConfig* feature_config);

  // .CameraConfig.CameraModel camera_model = 2;
  bool has_camera_model() const;
  void clear_camera_model();
  static const int kCameraModelFieldNumber = 2;
  private:
  const ::CameraConfig::CameraModel& _internal_camera_model() const;
  public:
  const ::CameraConfig::CameraModel& camera_model() const;
  ::CameraConfig::CameraModel* release_camera_model();
  ::CameraConfig::CameraModel* mutable_camera_model();
  void set_allocated_camera_model(::CameraConfig::CameraModel* camera_model);

  // @@protoc_insertion_point(class_scope:CameraConfig.Config)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CameraConfig::FeatureConfig* feature_config_;
  ::CameraConfig::CameraModel* camera_model_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FeatureConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.FeatureConfig) */ {
 public:
  FeatureConfig();
  virtual ~FeatureConfig();

  FeatureConfig(const FeatureConfig& from);

  inline FeatureConfig& operator=(const FeatureConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeatureConfig(FeatureConfig&& from) noexcept
    : FeatureConfig() {
    *this = ::std::move(from);
  }

  inline FeatureConfig& operator=(FeatureConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureConfig* internal_default_instance() {
    return reinterpret_cast<const FeatureConfig*>(
               &_FeatureConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(FeatureConfig* other);
  friend void swap(FeatureConfig& a, FeatureConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeatureConfig* New() const final {
    return CreateMaybeMessage<FeatureConfig>(NULL);
  }

  FeatureConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FeatureConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FeatureConfig& from);
  void MergeFrom(const FeatureConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .CameraConfig.SuperPoint super_point = 3;
  bool has_super_point() const;
  void clear_super_point();
  static const int kSuperPointFieldNumber = 3;
  private:
  const ::CameraConfig::SuperPoint& _internal_super_point() const;
  public:
  const ::CameraConfig::SuperPoint& super_point() const;
  ::CameraConfig::SuperPoint* release_super_point();
  ::CameraConfig::SuperPoint* mutable_super_point();
  void set_allocated_super_point(::CameraConfig::SuperPoint* super_point);

  // .CameraConfig.SuperGlue super_glue = 4;
  bool has_super_glue() const;
  void clear_super_glue();
  static const int kSuperGlueFieldNumber = 4;
  private:
  const ::CameraConfig::SuperGlue& _internal_super_glue() const;
  public:
  const ::CameraConfig::SuperGlue& super_glue() const;
  ::CameraConfig::SuperGlue* release_super_glue();
  ::CameraConfig::SuperGlue* mutable_super_glue();
  void set_allocated_super_glue(::CameraConfig::SuperGlue* super_glue);

  // .CameraConfig.ORBSLAM orb_slam = 5;
  bool has_orb_slam() const;
  void clear_orb_slam();
  static const int kOrbSlamFieldNumber = 5;
  private:
  const ::CameraConfig::ORBSLAM& _internal_orb_slam() const;
  public:
  const ::CameraConfig::ORBSLAM& orb_slam() const;
  ::CameraConfig::ORBSLAM* release_orb_slam();
  ::CameraConfig::ORBSLAM* mutable_orb_slam();
  void set_allocated_orb_slam(::CameraConfig::ORBSLAM* orb_slam);

  // .CameraConfig.FeatureTrackerConfig tracker_config = 7;
  bool has_tracker_config() const;
  void clear_tracker_config();
  static const int kTrackerConfigFieldNumber = 7;
  private:
  const ::CameraConfig::FeatureTrackerConfig& _internal_tracker_config() const;
  public:
  const ::CameraConfig::FeatureTrackerConfig& tracker_config() const;
  ::CameraConfig::FeatureTrackerConfig* release_tracker_config();
  ::CameraConfig::FeatureTrackerConfig* mutable_tracker_config();
  void set_allocated_tracker_config(::CameraConfig::FeatureTrackerConfig* tracker_config);

  // .CameraConfig.FeatureType feature_type = 1;
  void clear_feature_type();
  static const int kFeatureTypeFieldNumber = 1;
  ::CameraConfig::FeatureType feature_type() const;
  void set_feature_type(::CameraConfig::FeatureType value);

  // .CameraConfig.DescriptorType descriptor_type = 2;
  void clear_descriptor_type();
  static const int kDescriptorTypeFieldNumber = 2;
  ::CameraConfig::DescriptorType descriptor_type() const;
  void set_descriptor_type(::CameraConfig::DescriptorType value);

  // .CameraConfig.MatcherType matcher_type = 6;
  void clear_matcher_type();
  static const int kMatcherTypeFieldNumber = 6;
  ::CameraConfig::MatcherType matcher_type() const;
  void set_matcher_type(::CameraConfig::MatcherType value);

  // @@protoc_insertion_point(class_scope:CameraConfig.FeatureConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CameraConfig::SuperPoint* super_point_;
  ::CameraConfig::SuperGlue* super_glue_;
  ::CameraConfig::ORBSLAM* orb_slam_;
  ::CameraConfig::FeatureTrackerConfig* tracker_config_;
  int feature_type_;
  int descriptor_type_;
  int matcher_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SuperPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.SuperPoint) */ {
 public:
  SuperPoint();
  virtual ~SuperPoint();

  SuperPoint(const SuperPoint& from);

  inline SuperPoint& operator=(const SuperPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SuperPoint(SuperPoint&& from) noexcept
    : SuperPoint() {
    *this = ::std::move(from);
  }

  inline SuperPoint& operator=(SuperPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SuperPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SuperPoint* internal_default_instance() {
    return reinterpret_cast<const SuperPoint*>(
               &_SuperPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SuperPoint* other);
  friend void swap(SuperPoint& a, SuperPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SuperPoint* New() const final {
    return CreateMaybeMessage<SuperPoint>(NULL);
  }

  SuperPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SuperPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SuperPoint& from);
  void MergeFrom(const SuperPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuperPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TensorRTConfig.Config tensor_config = 6;
  bool has_tensor_config() const;
  void clear_tensor_config();
  static const int kTensorConfigFieldNumber = 6;
  private:
  const ::TensorRTConfig::Config& _internal_tensor_config() const;
  public:
  const ::TensorRTConfig::Config& tensor_config() const;
  ::TensorRTConfig::Config* release_tensor_config();
  ::TensorRTConfig::Config* mutable_tensor_config();
  void set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config);

  // int32 image_width = 1;
  void clear_image_width();
  static const int kImageWidthFieldNumber = 1;
  ::google::protobuf::int32 image_width() const;
  void set_image_width(::google::protobuf::int32 value);

  // int32 image_height = 2;
  void clear_image_height();
  static const int kImageHeightFieldNumber = 2;
  ::google::protobuf::int32 image_height() const;
  void set_image_height(::google::protobuf::int32 value);

  // double keypoint_threshold = 4;
  void clear_keypoint_threshold();
  static const int kKeypointThresholdFieldNumber = 4;
  double keypoint_threshold() const;
  void set_keypoint_threshold(double value);

  // int32 max_keypoints = 3;
  void clear_max_keypoints();
  static const int kMaxKeypointsFieldNumber = 3;
  ::google::protobuf::int32 max_keypoints() const;
  void set_max_keypoints(::google::protobuf::int32 value);

  // int32 remove_borders = 5;
  void clear_remove_borders();
  static const int kRemoveBordersFieldNumber = 5;
  ::google::protobuf::int32 remove_borders() const;
  void set_remove_borders(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CameraConfig.SuperPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::TensorRTConfig::Config* tensor_config_;
  ::google::protobuf::int32 image_width_;
  ::google::protobuf::int32 image_height_;
  double keypoint_threshold_;
  ::google::protobuf::int32 max_keypoints_;
  ::google::protobuf::int32 remove_borders_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SuperGlue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.SuperGlue) */ {
 public:
  SuperGlue();
  virtual ~SuperGlue();

  SuperGlue(const SuperGlue& from);

  inline SuperGlue& operator=(const SuperGlue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SuperGlue(SuperGlue&& from) noexcept
    : SuperGlue() {
    *this = ::std::move(from);
  }

  inline SuperGlue& operator=(SuperGlue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SuperGlue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SuperGlue* internal_default_instance() {
    return reinterpret_cast<const SuperGlue*>(
               &_SuperGlue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SuperGlue* other);
  friend void swap(SuperGlue& a, SuperGlue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SuperGlue* New() const final {
    return CreateMaybeMessage<SuperGlue>(NULL);
  }

  SuperGlue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SuperGlue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SuperGlue& from);
  void MergeFrom(const SuperGlue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuperGlue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TensorRTConfig.Config tensor_config = 7;
  bool has_tensor_config() const;
  void clear_tensor_config();
  static const int kTensorConfigFieldNumber = 7;
  private:
  const ::TensorRTConfig::Config& _internal_tensor_config() const;
  public:
  const ::TensorRTConfig::Config& tensor_config() const;
  ::TensorRTConfig::Config* release_tensor_config();
  ::TensorRTConfig::Config* mutable_tensor_config();
  void set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config);

  // int32 image_width = 1;
  void clear_image_width();
  static const int kImageWidthFieldNumber = 1;
  ::google::protobuf::int32 image_width() const;
  void set_image_width(::google::protobuf::int32 value);

  // int32 image_height = 2;
  void clear_image_height();
  static const int kImageHeightFieldNumber = 2;
  ::google::protobuf::int32 image_height() const;
  void set_image_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CameraConfig.SuperGlue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::TensorRTConfig::Config* tensor_config_;
  ::google::protobuf::int32 image_width_;
  ::google::protobuf::int32 image_height_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FeatureTrackerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.FeatureTrackerConfig) */ {
 public:
  FeatureTrackerConfig();
  virtual ~FeatureTrackerConfig();

  FeatureTrackerConfig(const FeatureTrackerConfig& from);

  inline FeatureTrackerConfig& operator=(const FeatureTrackerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeatureTrackerConfig(FeatureTrackerConfig&& from) noexcept
    : FeatureTrackerConfig() {
    *this = ::std::move(from);
  }

  inline FeatureTrackerConfig& operator=(FeatureTrackerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureTrackerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureTrackerConfig* internal_default_instance() {
    return reinterpret_cast<const FeatureTrackerConfig*>(
               &_FeatureTrackerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FeatureTrackerConfig* other);
  friend void swap(FeatureTrackerConfig& a, FeatureTrackerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeatureTrackerConfig* New() const final {
    return CreateMaybeMessage<FeatureTrackerConfig>(NULL);
  }

  FeatureTrackerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FeatureTrackerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FeatureTrackerConfig& from);
  void MergeFrom(const FeatureTrackerConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureTrackerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FeatureTrackerConfig_TrackerMothod TrackerMothod;
  static const TrackerMothod KLOPTICALFLOW =
    FeatureTrackerConfig_TrackerMothod_KLOPTICALFLOW;
  static const TrackerMothod FEATUREMATCH =
    FeatureTrackerConfig_TrackerMothod_FEATUREMATCH;
  static inline bool TrackerMothod_IsValid(int value) {
    return FeatureTrackerConfig_TrackerMothod_IsValid(value);
  }
  static const TrackerMothod TrackerMothod_MIN =
    FeatureTrackerConfig_TrackerMothod_TrackerMothod_MIN;
  static const TrackerMothod TrackerMothod_MAX =
    FeatureTrackerConfig_TrackerMothod_TrackerMothod_MAX;
  static const int TrackerMothod_ARRAYSIZE =
    FeatureTrackerConfig_TrackerMothod_TrackerMothod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrackerMothod_descriptor() {
    return FeatureTrackerConfig_TrackerMothod_descriptor();
  }
  static inline const ::std::string& TrackerMothod_Name(TrackerMothod value) {
    return FeatureTrackerConfig_TrackerMothod_Name(value);
  }
  static inline bool TrackerMothod_Parse(const ::std::string& name,
      TrackerMothod* value) {
    return FeatureTrackerConfig_TrackerMothod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .CameraConfig.KLOpticalFlowConfig kloptical_flow_config = 2;
  bool has_kloptical_flow_config() const;
  void clear_kloptical_flow_config();
  static const int kKlopticalFlowConfigFieldNumber = 2;
  private:
  const ::CameraConfig::KLOpticalFlowConfig& _internal_kloptical_flow_config() const;
  public:
  const ::CameraConfig::KLOpticalFlowConfig& kloptical_flow_config() const;
  ::CameraConfig::KLOpticalFlowConfig* release_kloptical_flow_config();
  ::CameraConfig::KLOpticalFlowConfig* mutable_kloptical_flow_config();
  void set_allocated_kloptical_flow_config(::CameraConfig::KLOpticalFlowConfig* kloptical_flow_config);

  // .CameraConfig.OpenStereoConfig open_stereo_config = 3;
  bool has_open_stereo_config() const;
  void clear_open_stereo_config();
  static const int kOpenStereoConfigFieldNumber = 3;
  private:
  const ::CameraConfig::OpenStereoConfig& _internal_open_stereo_config() const;
  public:
  const ::CameraConfig::OpenStereoConfig& open_stereo_config() const;
  ::CameraConfig::OpenStereoConfig* release_open_stereo_config();
  ::CameraConfig::OpenStereoConfig* mutable_open_stereo_config();
  void set_allocated_open_stereo_config(::CameraConfig::OpenStereoConfig* open_stereo_config);

  // .CameraConfig.FeatureTrackerConfig.TrackerMothod tracker_method = 1;
  void clear_tracker_method();
  static const int kTrackerMethodFieldNumber = 1;
  ::CameraConfig::FeatureTrackerConfig_TrackerMothod tracker_method() const;
  void set_tracker_method(::CameraConfig::FeatureTrackerConfig_TrackerMothod value);

  // @@protoc_insertion_point(class_scope:CameraConfig.FeatureTrackerConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CameraConfig::KLOpticalFlowConfig* kloptical_flow_config_;
  ::CameraConfig::OpenStereoConfig* open_stereo_config_;
  int tracker_method_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpenStereoConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.OpenStereoConfig) */ {
 public:
  OpenStereoConfig();
  virtual ~OpenStereoConfig();

  OpenStereoConfig(const OpenStereoConfig& from);

  inline OpenStereoConfig& operator=(const OpenStereoConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenStereoConfig(OpenStereoConfig&& from) noexcept
    : OpenStereoConfig() {
    *this = ::std::move(from);
  }

  inline OpenStereoConfig& operator=(OpenStereoConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenStereoConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenStereoConfig* internal_default_instance() {
    return reinterpret_cast<const OpenStereoConfig*>(
               &_OpenStereoConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(OpenStereoConfig* other);
  friend void swap(OpenStereoConfig& a, OpenStereoConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenStereoConfig* New() const final {
    return CreateMaybeMessage<OpenStereoConfig>(NULL);
  }

  OpenStereoConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OpenStereoConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OpenStereoConfig& from);
  void MergeFrom(const OpenStereoConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenStereoConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TensorRTConfig.Config tensor_config = 1;
  bool has_tensor_config() const;
  void clear_tensor_config();
  static const int kTensorConfigFieldNumber = 1;
  private:
  const ::TensorRTConfig::Config& _internal_tensor_config() const;
  public:
  const ::TensorRTConfig::Config& tensor_config() const;
  ::TensorRTConfig::Config* release_tensor_config();
  ::TensorRTConfig::Config* mutable_tensor_config();
  void set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config);

  // @@protoc_insertion_point(class_scope:CameraConfig.OpenStereoConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::TensorRTConfig::Config* tensor_config_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KLOpticalFlowConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.KLOpticalFlowConfig) */ {
 public:
  KLOpticalFlowConfig();
  virtual ~KLOpticalFlowConfig();

  KLOpticalFlowConfig(const KLOpticalFlowConfig& from);

  inline KLOpticalFlowConfig& operator=(const KLOpticalFlowConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KLOpticalFlowConfig(KLOpticalFlowConfig&& from) noexcept
    : KLOpticalFlowConfig() {
    *this = ::std::move(from);
  }

  inline KLOpticalFlowConfig& operator=(KLOpticalFlowConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KLOpticalFlowConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KLOpticalFlowConfig* internal_default_instance() {
    return reinterpret_cast<const KLOpticalFlowConfig*>(
               &_KLOpticalFlowConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(KLOpticalFlowConfig* other);
  friend void swap(KLOpticalFlowConfig& a, KLOpticalFlowConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KLOpticalFlowConfig* New() const final {
    return CreateMaybeMessage<KLOpticalFlowConfig>(NULL);
  }

  KLOpticalFlowConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KLOpticalFlowConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KLOpticalFlowConfig& from);
  void MergeFrom(const KLOpticalFlowConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KLOpticalFlowConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool enable_klopflow = 1;
  void clear_enable_klopflow();
  static const int kEnableKlopflowFieldNumber = 1;
  bool enable_klopflow() const;
  void set_enable_klopflow(bool value);

  // bool reverse_check = 2;
  void clear_reverse_check();
  static const int kReverseCheckFieldNumber = 2;
  bool reverse_check() const;
  void set_reverse_check(bool value);

  // int32 min_tracked_nums = 4;
  void clear_min_tracked_nums();
  static const int kMinTrackedNumsFieldNumber = 4;
  ::google::protobuf::int32 min_tracked_nums() const;
  void set_min_tracked_nums(::google::protobuf::int32 value);

  // double pt_err = 3;
  void clear_pt_err();
  static const int kPtErrFieldNumber = 3;
  double pt_err() const;
  void set_pt_err(double value);

  // @@protoc_insertion_point(class_scope:CameraConfig.KLOpticalFlowConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool enable_klopflow_;
  bool reverse_check_;
  ::google::protobuf::int32 min_tracked_nums_;
  double pt_err_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ORBSLAM : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.ORBSLAM) */ {
 public:
  ORBSLAM();
  virtual ~ORBSLAM();

  ORBSLAM(const ORBSLAM& from);

  inline ORBSLAM& operator=(const ORBSLAM& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ORBSLAM(ORBSLAM&& from) noexcept
    : ORBSLAM() {
    *this = ::std::move(from);
  }

  inline ORBSLAM& operator=(ORBSLAM&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ORBSLAM& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ORBSLAM* internal_default_instance() {
    return reinterpret_cast<const ORBSLAM*>(
               &_ORBSLAM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ORBSLAM* other);
  friend void swap(ORBSLAM& a, ORBSLAM& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ORBSLAM* New() const final {
    return CreateMaybeMessage<ORBSLAM>(NULL);
  }

  ORBSLAM* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ORBSLAM>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ORBSLAM& from);
  void MergeFrom(const ORBSLAM& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ORBSLAM* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CameraConfig.ORBSLAM)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PinholeConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.PinholeConfig) */ {
 public:
  PinholeConfig();
  virtual ~PinholeConfig();

  PinholeConfig(const PinholeConfig& from);

  inline PinholeConfig& operator=(const PinholeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PinholeConfig(PinholeConfig&& from) noexcept
    : PinholeConfig() {
    *this = ::std::move(from);
  }

  inline PinholeConfig& operator=(PinholeConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PinholeConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PinholeConfig* internal_default_instance() {
    return reinterpret_cast<const PinholeConfig*>(
               &_PinholeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(PinholeConfig* other);
  friend void swap(PinholeConfig& a, PinholeConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PinholeConfig* New() const final {
    return CreateMaybeMessage<PinholeConfig>(NULL);
  }

  PinholeConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PinholeConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PinholeConfig& from);
  void MergeFrom(const PinholeConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PinholeConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double fx = 1;
  void clear_fx();
  static const int kFxFieldNumber = 1;
  double fx() const;
  void set_fx(double value);

  // double fy = 2;
  void clear_fy();
  static const int kFyFieldNumber = 2;
  double fy() const;
  void set_fy(double value);

  // double cx = 3;
  void clear_cx();
  static const int kCxFieldNumber = 3;
  double cx() const;
  void set_cx(double value);

  // double cy = 4;
  void clear_cy();
  static const int kCyFieldNumber = 4;
  double cy() const;
  void set_cy(double value);

  // double k1 = 5;
  void clear_k1();
  static const int kK1FieldNumber = 5;
  double k1() const;
  void set_k1(double value);

  // double k2 = 6;
  void clear_k2();
  static const int kK2FieldNumber = 6;
  double k2() const;
  void set_k2(double value);

  // double p1 = 7;
  void clear_p1();
  static const int kP1FieldNumber = 7;
  double p1() const;
  void set_p1(double value);

  // double p2 = 8;
  void clear_p2();
  static const int kP2FieldNumber = 8;
  double p2() const;
  void set_p2(double value);

  // double focal_length = 9;
  void clear_focal_length();
  static const int kFocalLengthFieldNumber = 9;
  double focal_length() const;
  void set_focal_length(double value);

  // int32 iter_times = 10;
  void clear_iter_times();
  static const int kIterTimesFieldNumber = 10;
  ::google::protobuf::int32 iter_times() const;
  void set_iter_times(::google::protobuf::int32 value);

  // bool enable_cv_undistort = 11;
  void clear_enable_cv_undistort();
  static const int kEnableCvUndistortFieldNumber = 11;
  bool enable_cv_undistort() const;
  void set_enable_cv_undistort(bool value);

  // @@protoc_insertion_point(class_scope:CameraConfig.PinholeConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double fx_;
  double fy_;
  double cx_;
  double cy_;
  double k1_;
  double k2_;
  double p1_;
  double p2_;
  double focal_length_;
  ::google::protobuf::int32 iter_times_;
  bool enable_cv_undistort_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FishEyeConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.FishEyeConfig) */ {
 public:
  FishEyeConfig();
  virtual ~FishEyeConfig();

  FishEyeConfig(const FishEyeConfig& from);

  inline FishEyeConfig& operator=(const FishEyeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FishEyeConfig(FishEyeConfig&& from) noexcept
    : FishEyeConfig() {
    *this = ::std::move(from);
  }

  inline FishEyeConfig& operator=(FishEyeConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FishEyeConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FishEyeConfig* internal_default_instance() {
    return reinterpret_cast<const FishEyeConfig*>(
               &_FishEyeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(FishEyeConfig* other);
  friend void swap(FishEyeConfig& a, FishEyeConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FishEyeConfig* New() const final {
    return CreateMaybeMessage<FishEyeConfig>(NULL);
  }

  FishEyeConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FishEyeConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FishEyeConfig& from);
  void MergeFrom(const FishEyeConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FishEyeConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double fx = 1;
  void clear_fx();
  static const int kFxFieldNumber = 1;
  double fx() const;
  void set_fx(double value);

  // double fy = 2;
  void clear_fy();
  static const int kFyFieldNumber = 2;
  double fy() const;
  void set_fy(double value);

  // double cx = 3;
  void clear_cx();
  static const int kCxFieldNumber = 3;
  double cx() const;
  void set_cx(double value);

  // double cy = 4;
  void clear_cy();
  static const int kCyFieldNumber = 4;
  double cy() const;
  void set_cy(double value);

  // double k1 = 5;
  void clear_k1();
  static const int kK1FieldNumber = 5;
  double k1() const;
  void set_k1(double value);

  // double k2 = 6;
  void clear_k2();
  static const int kK2FieldNumber = 6;
  double k2() const;
  void set_k2(double value);

  // double k3 = 7;
  void clear_k3();
  static const int kK3FieldNumber = 7;
  double k3() const;
  void set_k3(double value);

  // double k4 = 8;
  void clear_k4();
  static const int kK4FieldNumber = 8;
  double k4() const;
  void set_k4(double value);

  // double focal_length = 9;
  void clear_focal_length();
  static const int kFocalLengthFieldNumber = 9;
  double focal_length() const;
  void set_focal_length(double value);

  // int32 iter_times = 10;
  void clear_iter_times();
  static const int kIterTimesFieldNumber = 10;
  ::google::protobuf::int32 iter_times() const;
  void set_iter_times(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CameraConfig.FishEyeConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double fx_;
  double fy_;
  double cx_;
  double cy_;
  double k1_;
  double k2_;
  double k3_;
  double k4_;
  double focal_length_;
  ::google::protobuf::int32 iter_times_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CameraModel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.CameraModel) */ {
 public:
  CameraModel();
  virtual ~CameraModel();

  CameraModel(const CameraModel& from);

  inline CameraModel& operator=(const CameraModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraModel(CameraModel&& from) noexcept
    : CameraModel() {
    *this = ::std::move(from);
  }

  inline CameraModel& operator=(CameraModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraModel* internal_default_instance() {
    return reinterpret_cast<const CameraModel*>(
               &_CameraModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CameraModel* other);
  friend void swap(CameraModel& a, CameraModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraModel* New() const final {
    return CreateMaybeMessage<CameraModel>(NULL);
  }

  CameraModel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CameraModel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CameraModel& from);
  void MergeFrom(const CameraModel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CameraModel_CameraType CameraType;
  static const CameraType PINHOLE =
    CameraModel_CameraType_PINHOLE;
  static const CameraType FISHEYE =
    CameraModel_CameraType_FISHEYE;
  static inline bool CameraType_IsValid(int value) {
    return CameraModel_CameraType_IsValid(value);
  }
  static const CameraType CameraType_MIN =
    CameraModel_CameraType_CameraType_MIN;
  static const CameraType CameraType_MAX =
    CameraModel_CameraType_CameraType_MAX;
  static const int CameraType_ARRAYSIZE =
    CameraModel_CameraType_CameraType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CameraType_descriptor() {
    return CameraModel_CameraType_descriptor();
  }
  static inline const ::std::string& CameraType_Name(CameraType value) {
    return CameraModel_CameraType_Name(value);
  }
  static inline bool CameraType_Parse(const ::std::string& name,
      CameraType* value) {
    return CameraModel_CameraType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .CameraConfig.PinholeConfig pinhole_config = 2;
  bool has_pinhole_config() const;
  void clear_pinhole_config();
  static const int kPinholeConfigFieldNumber = 2;
  private:
  const ::CameraConfig::PinholeConfig& _internal_pinhole_config() const;
  public:
  const ::CameraConfig::PinholeConfig& pinhole_config() const;
  ::CameraConfig::PinholeConfig* release_pinhole_config();
  ::CameraConfig::PinholeConfig* mutable_pinhole_config();
  void set_allocated_pinhole_config(::CameraConfig::PinholeConfig* pinhole_config);

  // .CameraConfig.FishEyeConfig fish_eye_config = 3;
  bool has_fish_eye_config() const;
  void clear_fish_eye_config();
  static const int kFishEyeConfigFieldNumber = 3;
  private:
  const ::CameraConfig::FishEyeConfig& _internal_fish_eye_config() const;
  public:
  const ::CameraConfig::FishEyeConfig& fish_eye_config() const;
  ::CameraConfig::FishEyeConfig* release_fish_eye_config();
  ::CameraConfig::FishEyeConfig* mutable_fish_eye_config();
  void set_allocated_fish_eye_config(::CameraConfig::FishEyeConfig* fish_eye_config);

  // .CameraConfig.CameraModel.CameraType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::CameraConfig::CameraModel_CameraType type() const;
  void set_type(::CameraConfig::CameraModel_CameraType value);

  // @@protoc_insertion_point(class_scope:CameraConfig.CameraModel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CameraConfig::PinholeConfig* pinhole_config_;
  ::CameraConfig::FishEyeConfig* fish_eye_config_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SFMConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.SFMConfig) */ {
 public:
  SFMConfig();
  virtual ~SFMConfig();

  SFMConfig(const SFMConfig& from);

  inline SFMConfig& operator=(const SFMConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SFMConfig(SFMConfig&& from) noexcept
    : SFMConfig() {
    *this = ::std::move(from);
  }

  inline SFMConfig& operator=(SFMConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SFMConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SFMConfig* internal_default_instance() {
    return reinterpret_cast<const SFMConfig*>(
               &_SFMConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SFMConfig* other);
  friend void swap(SFMConfig& a, SFMConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SFMConfig* New() const final {
    return CreateMaybeMessage<SFMConfig>(NULL);
  }

  SFMConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SFMConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SFMConfig& from);
  void MergeFrom(const SFMConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SFMConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SFMConfig_DecomposeHMethod DecomposeHMethod;
  static const DecomposeHMethod ZHANG =
    SFMConfig_DecomposeHMethod_ZHANG;
  static const DecomposeHMethod Ezio_Malis =
    SFMConfig_DecomposeHMethod_Ezio_Malis;
  static inline bool DecomposeHMethod_IsValid(int value) {
    return SFMConfig_DecomposeHMethod_IsValid(value);
  }
  static const DecomposeHMethod DecomposeHMethod_MIN =
    SFMConfig_DecomposeHMethod_DecomposeHMethod_MIN;
  static const DecomposeHMethod DecomposeHMethod_MAX =
    SFMConfig_DecomposeHMethod_DecomposeHMethod_MAX;
  static const int DecomposeHMethod_ARRAYSIZE =
    SFMConfig_DecomposeHMethod_DecomposeHMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DecomposeHMethod_descriptor() {
    return SFMConfig_DecomposeHMethod_descriptor();
  }
  static inline const ::std::string& DecomposeHMethod_Name(DecomposeHMethod value) {
    return SFMConfig_DecomposeHMethod_Name(value);
  }
  static inline bool DecomposeHMethod_Parse(const ::std::string& name,
      DecomposeHMethod* value) {
    return SFMConfig_DecomposeHMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .CameraConfig.CameraModel camera_model = 1;
  bool has_camera_model() const;
  void clear_camera_model();
  static const int kCameraModelFieldNumber = 1;
  private:
  const ::CameraConfig::CameraModel& _internal_camera_model() const;
  public:
  const ::CameraConfig::CameraModel& camera_model() const;
  ::CameraConfig::CameraModel* release_camera_model();
  ::CameraConfig::CameraModel* mutable_camera_model();
  void set_allocated_camera_model(::CameraConfig::CameraModel* camera_model);

  // .CameraConfig.PnpSolverConfig pnp_solver = 2;
  bool has_pnp_solver() const;
  void clear_pnp_solver();
  static const int kPnpSolverFieldNumber = 2;
  private:
  const ::CameraConfig::PnpSolverConfig& _internal_pnp_solver() const;
  public:
  const ::CameraConfig::PnpSolverConfig& pnp_solver() const;
  ::CameraConfig::PnpSolverConfig* release_pnp_solver();
  ::CameraConfig::PnpSolverConfig* mutable_pnp_solver();
  void set_allocated_pnp_solver(::CameraConfig::PnpSolverConfig* pnp_solver);

  // .CameraConfig.FeatureConfig feature_config = 3;
  bool has_feature_config() const;
  void clear_feature_config();
  static const int kFeatureConfigFieldNumber = 3;
  private:
  const ::CameraConfig::FeatureConfig& _internal_feature_config() const;
  public:
  const ::CameraConfig::FeatureConfig& feature_config() const;
  ::CameraConfig::FeatureConfig* release_feature_config();
  ::CameraConfig::FeatureConfig* mutable_feature_config();
  void set_allocated_feature_config(::CameraConfig::FeatureConfig* feature_config);

  // bool enable_cv_p2p = 4;
  void clear_enable_cv_p2p();
  static const int kEnableCvP2PFieldNumber = 4;
  bool enable_cv_p2p() const;
  void set_enable_cv_p2p(bool value);

  // int32 ransac_iterations = 5;
  void clear_ransac_iterations();
  static const int kRansacIterationsFieldNumber = 5;
  ::google::protobuf::int32 ransac_iterations() const;
  void set_ransac_iterations(::google::protobuf::int32 value);

  // double reproj_err_th = 6;
  void clear_reproj_err_th();
  static const int kReprojErrThFieldNumber = 6;
  double reproj_err_th() const;
  void set_reproj_err_th(double value);

  // double sigma = 7;
  void clear_sigma();
  static const int kSigmaFieldNumber = 7;
  double sigma() const;
  void set_sigma(double value);

  // .CameraConfig.SFMConfig.DecomposeHMethod decompose_H_method = 8;
  void clear_decompose_h_method();
  static const int kDecomposeHMethodFieldNumber = 8;
  ::CameraConfig::SFMConfig_DecomposeHMethod decompose_h_method() const;
  void set_decompose_h_method(::CameraConfig::SFMConfig_DecomposeHMethod value);

  // @@protoc_insertion_point(class_scope:CameraConfig.SFMConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::CameraConfig::CameraModel* camera_model_;
  ::CameraConfig::PnpSolverConfig* pnp_solver_;
  ::CameraConfig::FeatureConfig* feature_config_;
  bool enable_cv_p2p_;
  ::google::protobuf::int32 ransac_iterations_;
  double reproj_err_th_;
  double sigma_;
  int decompose_h_method_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PnpSolverConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CameraConfig.PnpSolverConfig) */ {
 public:
  PnpSolverConfig();
  virtual ~PnpSolverConfig();

  PnpSolverConfig(const PnpSolverConfig& from);

  inline PnpSolverConfig& operator=(const PnpSolverConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PnpSolverConfig(PnpSolverConfig&& from) noexcept
    : PnpSolverConfig() {
    *this = ::std::move(from);
  }

  inline PnpSolverConfig& operator=(PnpSolverConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PnpSolverConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PnpSolverConfig* internal_default_instance() {
    return reinterpret_cast<const PnpSolverConfig*>(
               &_PnpSolverConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(PnpSolverConfig* other);
  friend void swap(PnpSolverConfig& a, PnpSolverConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PnpSolverConfig* New() const final {
    return CreateMaybeMessage<PnpSolverConfig>(NULL);
  }

  PnpSolverConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PnpSolverConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PnpSolverConfig& from);
  void MergeFrom(const PnpSolverConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PnpSolverConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PnpSolverConfig_PnpSolveMethod PnpSolveMethod;
  static const PnpSolveMethod DLT =
    PnpSolverConfig_PnpSolveMethod_DLT;
  static const PnpSolveMethod BA =
    PnpSolverConfig_PnpSolveMethod_BA;
  static const PnpSolveMethod EPNP =
    PnpSolverConfig_PnpSolveMethod_EPNP;
  static const PnpSolveMethod MLPNP =
    PnpSolverConfig_PnpSolveMethod_MLPNP;
  static inline bool PnpSolveMethod_IsValid(int value) {
    return PnpSolverConfig_PnpSolveMethod_IsValid(value);
  }
  static const PnpSolveMethod PnpSolveMethod_MIN =
    PnpSolverConfig_PnpSolveMethod_PnpSolveMethod_MIN;
  static const PnpSolveMethod PnpSolveMethod_MAX =
    PnpSolverConfig_PnpSolveMethod_PnpSolveMethod_MAX;
  static const int PnpSolveMethod_ARRAYSIZE =
    PnpSolverConfig_PnpSolveMethod_PnpSolveMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PnpSolveMethod_descriptor() {
    return PnpSolverConfig_PnpSolveMethod_descriptor();
  }
  static inline const ::std::string& PnpSolveMethod_Name(PnpSolveMethod value) {
    return PnpSolverConfig_PnpSolveMethod_Name(value);
  }
  static inline bool PnpSolveMethod_Parse(const ::std::string& name,
      PnpSolveMethod* value) {
    return PnpSolverConfig_PnpSolveMethod_Parse(name, value);
  }

  typedef PnpSolverConfig_PnpCvMethod PnpCvMethod;
  static const PnpCvMethod OpenCV_SOLVEPNP_ITERATIVE =
    PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_ITERATIVE;
  static const PnpCvMethod OpenCV_SOLVEPNP_EPNP =
    PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_EPNP;
  static const PnpCvMethod OpenCV_SOLVEPNP_P3P =
    PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_P3P;
  static const PnpCvMethod OpenCV_SOLVEPNP_DLS =
    PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_DLS;
  static const PnpCvMethod OpenCV_SOLVEPNP_UPNP =
    PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_UPNP;
  static const PnpCvMethod OpenCV_SOLVEPNP_AP3P =
    PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_AP3P;
  static const PnpCvMethod OpenCV_SOLVEPNP_IPPE =
    PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_IPPE;
  static const PnpCvMethod OpenCV_SOLVEPNP_IPPE_SQUARE =
    PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_IPPE_SQUARE;
  static const PnpCvMethod OpenCV_SOLVEPNP_SQPNP =
    PnpSolverConfig_PnpCvMethod_OpenCV_SOLVEPNP_SQPNP;
  static inline bool PnpCvMethod_IsValid(int value) {
    return PnpSolverConfig_PnpCvMethod_IsValid(value);
  }
  static const PnpCvMethod PnpCvMethod_MIN =
    PnpSolverConfig_PnpCvMethod_PnpCvMethod_MIN;
  static const PnpCvMethod PnpCvMethod_MAX =
    PnpSolverConfig_PnpCvMethod_PnpCvMethod_MAX;
  static const int PnpCvMethod_ARRAYSIZE =
    PnpSolverConfig_PnpCvMethod_PnpCvMethod_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PnpCvMethod_descriptor() {
    return PnpSolverConfig_PnpCvMethod_descriptor();
  }
  static inline const ::std::string& PnpCvMethod_Name(PnpCvMethod value) {
    return PnpSolverConfig_PnpCvMethod_Name(value);
  }
  static inline bool PnpCvMethod_Parse(const ::std::string& name,
      PnpCvMethod* value) {
    return PnpSolverConfig_PnpCvMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bool enable_cv_pnp = 1;
  void clear_enable_cv_pnp();
  static const int kEnableCvPnpFieldNumber = 1;
  bool enable_cv_pnp() const;
  void set_enable_cv_pnp(bool value);

  // .CameraConfig.PnpSolverConfig.PnpSolveMethod pnp_solve_method = 2;
  void clear_pnp_solve_method();
  static const int kPnpSolveMethodFieldNumber = 2;
  ::CameraConfig::PnpSolverConfig_PnpSolveMethod pnp_solve_method() const;
  void set_pnp_solve_method(::CameraConfig::PnpSolverConfig_PnpSolveMethod value);

  // .CameraConfig.PnpSolverConfig.PnpCvMethod pnp_cv_method = 3;
  void clear_pnp_cv_method();
  static const int kPnpCvMethodFieldNumber = 3;
  ::CameraConfig::PnpSolverConfig_PnpCvMethod pnp_cv_method() const;
  void set_pnp_cv_method(::CameraConfig::PnpSolverConfig_PnpCvMethod value);

  // int32 max_iterations = 4;
  void clear_max_iterations();
  static const int kMaxIterationsFieldNumber = 4;
  ::google::protobuf::int32 max_iterations() const;
  void set_max_iterations(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CameraConfig.PnpSolverConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool enable_cv_pnp_;
  int pnp_solve_method_;
  int pnp_cv_method_;
  ::google::protobuf::int32 max_iterations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_camera_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Config

// .CameraConfig.FeatureConfig feature_config = 1;
inline bool Config::has_feature_config() const {
  return this != internal_default_instance() && feature_config_ != NULL;
}
inline void Config::clear_feature_config() {
  if (GetArenaNoVirtual() == NULL && feature_config_ != NULL) {
    delete feature_config_;
  }
  feature_config_ = NULL;
}
inline const ::CameraConfig::FeatureConfig& Config::_internal_feature_config() const {
  return *feature_config_;
}
inline const ::CameraConfig::FeatureConfig& Config::feature_config() const {
  const ::CameraConfig::FeatureConfig* p = feature_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.Config.feature_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::FeatureConfig*>(
      &::CameraConfig::_FeatureConfig_default_instance_);
}
inline ::CameraConfig::FeatureConfig* Config::release_feature_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.Config.feature_config)
  
  ::CameraConfig::FeatureConfig* temp = feature_config_;
  feature_config_ = NULL;
  return temp;
}
inline ::CameraConfig::FeatureConfig* Config::mutable_feature_config() {
  
  if (feature_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::FeatureConfig>(GetArenaNoVirtual());
    feature_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.Config.feature_config)
  return feature_config_;
}
inline void Config::set_allocated_feature_config(::CameraConfig::FeatureConfig* feature_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete feature_config_;
  }
  if (feature_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature_config, submessage_arena);
    }
    
  } else {
    
  }
  feature_config_ = feature_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.Config.feature_config)
}

// .CameraConfig.CameraModel camera_model = 2;
inline bool Config::has_camera_model() const {
  return this != internal_default_instance() && camera_model_ != NULL;
}
inline void Config::clear_camera_model() {
  if (GetArenaNoVirtual() == NULL && camera_model_ != NULL) {
    delete camera_model_;
  }
  camera_model_ = NULL;
}
inline const ::CameraConfig::CameraModel& Config::_internal_camera_model() const {
  return *camera_model_;
}
inline const ::CameraConfig::CameraModel& Config::camera_model() const {
  const ::CameraConfig::CameraModel* p = camera_model_;
  // @@protoc_insertion_point(field_get:CameraConfig.Config.camera_model)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::CameraModel*>(
      &::CameraConfig::_CameraModel_default_instance_);
}
inline ::CameraConfig::CameraModel* Config::release_camera_model() {
  // @@protoc_insertion_point(field_release:CameraConfig.Config.camera_model)
  
  ::CameraConfig::CameraModel* temp = camera_model_;
  camera_model_ = NULL;
  return temp;
}
inline ::CameraConfig::CameraModel* Config::mutable_camera_model() {
  
  if (camera_model_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::CameraModel>(GetArenaNoVirtual());
    camera_model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.Config.camera_model)
  return camera_model_;
}
inline void Config::set_allocated_camera_model(::CameraConfig::CameraModel* camera_model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete camera_model_;
  }
  if (camera_model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      camera_model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, camera_model, submessage_arena);
    }
    
  } else {
    
  }
  camera_model_ = camera_model;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.Config.camera_model)
}

// -------------------------------------------------------------------

// FeatureConfig

// .CameraConfig.FeatureType feature_type = 1;
inline void FeatureConfig::clear_feature_type() {
  feature_type_ = 0;
}
inline ::CameraConfig::FeatureType FeatureConfig::feature_type() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.feature_type)
  return static_cast< ::CameraConfig::FeatureType >(feature_type_);
}
inline void FeatureConfig::set_feature_type(::CameraConfig::FeatureType value) {
  
  feature_type_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FeatureConfig.feature_type)
}

// .CameraConfig.DescriptorType descriptor_type = 2;
inline void FeatureConfig::clear_descriptor_type() {
  descriptor_type_ = 0;
}
inline ::CameraConfig::DescriptorType FeatureConfig::descriptor_type() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.descriptor_type)
  return static_cast< ::CameraConfig::DescriptorType >(descriptor_type_);
}
inline void FeatureConfig::set_descriptor_type(::CameraConfig::DescriptorType value) {
  
  descriptor_type_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FeatureConfig.descriptor_type)
}

// .CameraConfig.SuperPoint super_point = 3;
inline bool FeatureConfig::has_super_point() const {
  return this != internal_default_instance() && super_point_ != NULL;
}
inline void FeatureConfig::clear_super_point() {
  if (GetArenaNoVirtual() == NULL && super_point_ != NULL) {
    delete super_point_;
  }
  super_point_ = NULL;
}
inline const ::CameraConfig::SuperPoint& FeatureConfig::_internal_super_point() const {
  return *super_point_;
}
inline const ::CameraConfig::SuperPoint& FeatureConfig::super_point() const {
  const ::CameraConfig::SuperPoint* p = super_point_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.super_point)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::SuperPoint*>(
      &::CameraConfig::_SuperPoint_default_instance_);
}
inline ::CameraConfig::SuperPoint* FeatureConfig::release_super_point() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureConfig.super_point)
  
  ::CameraConfig::SuperPoint* temp = super_point_;
  super_point_ = NULL;
  return temp;
}
inline ::CameraConfig::SuperPoint* FeatureConfig::mutable_super_point() {
  
  if (super_point_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::SuperPoint>(GetArenaNoVirtual());
    super_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureConfig.super_point)
  return super_point_;
}
inline void FeatureConfig::set_allocated_super_point(::CameraConfig::SuperPoint* super_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete super_point_;
  }
  if (super_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      super_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, super_point, submessage_arena);
    }
    
  } else {
    
  }
  super_point_ = super_point;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureConfig.super_point)
}

// .CameraConfig.SuperGlue super_glue = 4;
inline bool FeatureConfig::has_super_glue() const {
  return this != internal_default_instance() && super_glue_ != NULL;
}
inline void FeatureConfig::clear_super_glue() {
  if (GetArenaNoVirtual() == NULL && super_glue_ != NULL) {
    delete super_glue_;
  }
  super_glue_ = NULL;
}
inline const ::CameraConfig::SuperGlue& FeatureConfig::_internal_super_glue() const {
  return *super_glue_;
}
inline const ::CameraConfig::SuperGlue& FeatureConfig::super_glue() const {
  const ::CameraConfig::SuperGlue* p = super_glue_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.super_glue)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::SuperGlue*>(
      &::CameraConfig::_SuperGlue_default_instance_);
}
inline ::CameraConfig::SuperGlue* FeatureConfig::release_super_glue() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureConfig.super_glue)
  
  ::CameraConfig::SuperGlue* temp = super_glue_;
  super_glue_ = NULL;
  return temp;
}
inline ::CameraConfig::SuperGlue* FeatureConfig::mutable_super_glue() {
  
  if (super_glue_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::SuperGlue>(GetArenaNoVirtual());
    super_glue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureConfig.super_glue)
  return super_glue_;
}
inline void FeatureConfig::set_allocated_super_glue(::CameraConfig::SuperGlue* super_glue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete super_glue_;
  }
  if (super_glue) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      super_glue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, super_glue, submessage_arena);
    }
    
  } else {
    
  }
  super_glue_ = super_glue;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureConfig.super_glue)
}

// .CameraConfig.ORBSLAM orb_slam = 5;
inline bool FeatureConfig::has_orb_slam() const {
  return this != internal_default_instance() && orb_slam_ != NULL;
}
inline void FeatureConfig::clear_orb_slam() {
  if (GetArenaNoVirtual() == NULL && orb_slam_ != NULL) {
    delete orb_slam_;
  }
  orb_slam_ = NULL;
}
inline const ::CameraConfig::ORBSLAM& FeatureConfig::_internal_orb_slam() const {
  return *orb_slam_;
}
inline const ::CameraConfig::ORBSLAM& FeatureConfig::orb_slam() const {
  const ::CameraConfig::ORBSLAM* p = orb_slam_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.orb_slam)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::ORBSLAM*>(
      &::CameraConfig::_ORBSLAM_default_instance_);
}
inline ::CameraConfig::ORBSLAM* FeatureConfig::release_orb_slam() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureConfig.orb_slam)
  
  ::CameraConfig::ORBSLAM* temp = orb_slam_;
  orb_slam_ = NULL;
  return temp;
}
inline ::CameraConfig::ORBSLAM* FeatureConfig::mutable_orb_slam() {
  
  if (orb_slam_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::ORBSLAM>(GetArenaNoVirtual());
    orb_slam_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureConfig.orb_slam)
  return orb_slam_;
}
inline void FeatureConfig::set_allocated_orb_slam(::CameraConfig::ORBSLAM* orb_slam) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orb_slam_;
  }
  if (orb_slam) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orb_slam = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orb_slam, submessage_arena);
    }
    
  } else {
    
  }
  orb_slam_ = orb_slam;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureConfig.orb_slam)
}

// .CameraConfig.MatcherType matcher_type = 6;
inline void FeatureConfig::clear_matcher_type() {
  matcher_type_ = 0;
}
inline ::CameraConfig::MatcherType FeatureConfig::matcher_type() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.matcher_type)
  return static_cast< ::CameraConfig::MatcherType >(matcher_type_);
}
inline void FeatureConfig::set_matcher_type(::CameraConfig::MatcherType value) {
  
  matcher_type_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FeatureConfig.matcher_type)
}

// .CameraConfig.FeatureTrackerConfig tracker_config = 7;
inline bool FeatureConfig::has_tracker_config() const {
  return this != internal_default_instance() && tracker_config_ != NULL;
}
inline void FeatureConfig::clear_tracker_config() {
  if (GetArenaNoVirtual() == NULL && tracker_config_ != NULL) {
    delete tracker_config_;
  }
  tracker_config_ = NULL;
}
inline const ::CameraConfig::FeatureTrackerConfig& FeatureConfig::_internal_tracker_config() const {
  return *tracker_config_;
}
inline const ::CameraConfig::FeatureTrackerConfig& FeatureConfig::tracker_config() const {
  const ::CameraConfig::FeatureTrackerConfig* p = tracker_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureConfig.tracker_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::FeatureTrackerConfig*>(
      &::CameraConfig::_FeatureTrackerConfig_default_instance_);
}
inline ::CameraConfig::FeatureTrackerConfig* FeatureConfig::release_tracker_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureConfig.tracker_config)
  
  ::CameraConfig::FeatureTrackerConfig* temp = tracker_config_;
  tracker_config_ = NULL;
  return temp;
}
inline ::CameraConfig::FeatureTrackerConfig* FeatureConfig::mutable_tracker_config() {
  
  if (tracker_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::FeatureTrackerConfig>(GetArenaNoVirtual());
    tracker_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureConfig.tracker_config)
  return tracker_config_;
}
inline void FeatureConfig::set_allocated_tracker_config(::CameraConfig::FeatureTrackerConfig* tracker_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tracker_config_;
  }
  if (tracker_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tracker_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tracker_config, submessage_arena);
    }
    
  } else {
    
  }
  tracker_config_ = tracker_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureConfig.tracker_config)
}

// -------------------------------------------------------------------

// SuperPoint

// int32 image_width = 1;
inline void SuperPoint::clear_image_width() {
  image_width_ = 0;
}
inline ::google::protobuf::int32 SuperPoint::image_width() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.image_width)
  return image_width_;
}
inline void SuperPoint::set_image_width(::google::protobuf::int32 value) {
  
  image_width_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperPoint.image_width)
}

// int32 image_height = 2;
inline void SuperPoint::clear_image_height() {
  image_height_ = 0;
}
inline ::google::protobuf::int32 SuperPoint::image_height() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.image_height)
  return image_height_;
}
inline void SuperPoint::set_image_height(::google::protobuf::int32 value) {
  
  image_height_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperPoint.image_height)
}

// int32 max_keypoints = 3;
inline void SuperPoint::clear_max_keypoints() {
  max_keypoints_ = 0;
}
inline ::google::protobuf::int32 SuperPoint::max_keypoints() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.max_keypoints)
  return max_keypoints_;
}
inline void SuperPoint::set_max_keypoints(::google::protobuf::int32 value) {
  
  max_keypoints_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperPoint.max_keypoints)
}

// double keypoint_threshold = 4;
inline void SuperPoint::clear_keypoint_threshold() {
  keypoint_threshold_ = 0;
}
inline double SuperPoint::keypoint_threshold() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.keypoint_threshold)
  return keypoint_threshold_;
}
inline void SuperPoint::set_keypoint_threshold(double value) {
  
  keypoint_threshold_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperPoint.keypoint_threshold)
}

// int32 remove_borders = 5;
inline void SuperPoint::clear_remove_borders() {
  remove_borders_ = 0;
}
inline ::google::protobuf::int32 SuperPoint::remove_borders() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.remove_borders)
  return remove_borders_;
}
inline void SuperPoint::set_remove_borders(::google::protobuf::int32 value) {
  
  remove_borders_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperPoint.remove_borders)
}

// .TensorRTConfig.Config tensor_config = 6;
inline bool SuperPoint::has_tensor_config() const {
  return this != internal_default_instance() && tensor_config_ != NULL;
}
inline const ::TensorRTConfig::Config& SuperPoint::_internal_tensor_config() const {
  return *tensor_config_;
}
inline const ::TensorRTConfig::Config& SuperPoint::tensor_config() const {
  const ::TensorRTConfig::Config* p = tensor_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.SuperPoint.tensor_config)
  return p != NULL ? *p : *reinterpret_cast<const ::TensorRTConfig::Config*>(
      &::TensorRTConfig::_Config_default_instance_);
}
inline ::TensorRTConfig::Config* SuperPoint::release_tensor_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.SuperPoint.tensor_config)
  
  ::TensorRTConfig::Config* temp = tensor_config_;
  tensor_config_ = NULL;
  return temp;
}
inline ::TensorRTConfig::Config* SuperPoint::mutable_tensor_config() {
  
  if (tensor_config_ == NULL) {
    auto* p = CreateMaybeMessage<::TensorRTConfig::Config>(GetArenaNoVirtual());
    tensor_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.SuperPoint.tensor_config)
  return tensor_config_;
}
inline void SuperPoint::set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tensor_config_);
  }
  if (tensor_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tensor_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tensor_config, submessage_arena);
    }
    
  } else {
    
  }
  tensor_config_ = tensor_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.SuperPoint.tensor_config)
}

// -------------------------------------------------------------------

// SuperGlue

// int32 image_width = 1;
inline void SuperGlue::clear_image_width() {
  image_width_ = 0;
}
inline ::google::protobuf::int32 SuperGlue::image_width() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperGlue.image_width)
  return image_width_;
}
inline void SuperGlue::set_image_width(::google::protobuf::int32 value) {
  
  image_width_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperGlue.image_width)
}

// int32 image_height = 2;
inline void SuperGlue::clear_image_height() {
  image_height_ = 0;
}
inline ::google::protobuf::int32 SuperGlue::image_height() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SuperGlue.image_height)
  return image_height_;
}
inline void SuperGlue::set_image_height(::google::protobuf::int32 value) {
  
  image_height_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SuperGlue.image_height)
}

// .TensorRTConfig.Config tensor_config = 7;
inline bool SuperGlue::has_tensor_config() const {
  return this != internal_default_instance() && tensor_config_ != NULL;
}
inline const ::TensorRTConfig::Config& SuperGlue::_internal_tensor_config() const {
  return *tensor_config_;
}
inline const ::TensorRTConfig::Config& SuperGlue::tensor_config() const {
  const ::TensorRTConfig::Config* p = tensor_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.SuperGlue.tensor_config)
  return p != NULL ? *p : *reinterpret_cast<const ::TensorRTConfig::Config*>(
      &::TensorRTConfig::_Config_default_instance_);
}
inline ::TensorRTConfig::Config* SuperGlue::release_tensor_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.SuperGlue.tensor_config)
  
  ::TensorRTConfig::Config* temp = tensor_config_;
  tensor_config_ = NULL;
  return temp;
}
inline ::TensorRTConfig::Config* SuperGlue::mutable_tensor_config() {
  
  if (tensor_config_ == NULL) {
    auto* p = CreateMaybeMessage<::TensorRTConfig::Config>(GetArenaNoVirtual());
    tensor_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.SuperGlue.tensor_config)
  return tensor_config_;
}
inline void SuperGlue::set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tensor_config_);
  }
  if (tensor_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tensor_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tensor_config, submessage_arena);
    }
    
  } else {
    
  }
  tensor_config_ = tensor_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.SuperGlue.tensor_config)
}

// -------------------------------------------------------------------

// FeatureTrackerConfig

// .CameraConfig.FeatureTrackerConfig.TrackerMothod tracker_method = 1;
inline void FeatureTrackerConfig::clear_tracker_method() {
  tracker_method_ = 0;
}
inline ::CameraConfig::FeatureTrackerConfig_TrackerMothod FeatureTrackerConfig::tracker_method() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureTrackerConfig.tracker_method)
  return static_cast< ::CameraConfig::FeatureTrackerConfig_TrackerMothod >(tracker_method_);
}
inline void FeatureTrackerConfig::set_tracker_method(::CameraConfig::FeatureTrackerConfig_TrackerMothod value) {
  
  tracker_method_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FeatureTrackerConfig.tracker_method)
}

// .CameraConfig.KLOpticalFlowConfig kloptical_flow_config = 2;
inline bool FeatureTrackerConfig::has_kloptical_flow_config() const {
  return this != internal_default_instance() && kloptical_flow_config_ != NULL;
}
inline void FeatureTrackerConfig::clear_kloptical_flow_config() {
  if (GetArenaNoVirtual() == NULL && kloptical_flow_config_ != NULL) {
    delete kloptical_flow_config_;
  }
  kloptical_flow_config_ = NULL;
}
inline const ::CameraConfig::KLOpticalFlowConfig& FeatureTrackerConfig::_internal_kloptical_flow_config() const {
  return *kloptical_flow_config_;
}
inline const ::CameraConfig::KLOpticalFlowConfig& FeatureTrackerConfig::kloptical_flow_config() const {
  const ::CameraConfig::KLOpticalFlowConfig* p = kloptical_flow_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureTrackerConfig.kloptical_flow_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::KLOpticalFlowConfig*>(
      &::CameraConfig::_KLOpticalFlowConfig_default_instance_);
}
inline ::CameraConfig::KLOpticalFlowConfig* FeatureTrackerConfig::release_kloptical_flow_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureTrackerConfig.kloptical_flow_config)
  
  ::CameraConfig::KLOpticalFlowConfig* temp = kloptical_flow_config_;
  kloptical_flow_config_ = NULL;
  return temp;
}
inline ::CameraConfig::KLOpticalFlowConfig* FeatureTrackerConfig::mutable_kloptical_flow_config() {
  
  if (kloptical_flow_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::KLOpticalFlowConfig>(GetArenaNoVirtual());
    kloptical_flow_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureTrackerConfig.kloptical_flow_config)
  return kloptical_flow_config_;
}
inline void FeatureTrackerConfig::set_allocated_kloptical_flow_config(::CameraConfig::KLOpticalFlowConfig* kloptical_flow_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kloptical_flow_config_;
  }
  if (kloptical_flow_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kloptical_flow_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kloptical_flow_config, submessage_arena);
    }
    
  } else {
    
  }
  kloptical_flow_config_ = kloptical_flow_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureTrackerConfig.kloptical_flow_config)
}

// .CameraConfig.OpenStereoConfig open_stereo_config = 3;
inline bool FeatureTrackerConfig::has_open_stereo_config() const {
  return this != internal_default_instance() && open_stereo_config_ != NULL;
}
inline void FeatureTrackerConfig::clear_open_stereo_config() {
  if (GetArenaNoVirtual() == NULL && open_stereo_config_ != NULL) {
    delete open_stereo_config_;
  }
  open_stereo_config_ = NULL;
}
inline const ::CameraConfig::OpenStereoConfig& FeatureTrackerConfig::_internal_open_stereo_config() const {
  return *open_stereo_config_;
}
inline const ::CameraConfig::OpenStereoConfig& FeatureTrackerConfig::open_stereo_config() const {
  const ::CameraConfig::OpenStereoConfig* p = open_stereo_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.FeatureTrackerConfig.open_stereo_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::OpenStereoConfig*>(
      &::CameraConfig::_OpenStereoConfig_default_instance_);
}
inline ::CameraConfig::OpenStereoConfig* FeatureTrackerConfig::release_open_stereo_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.FeatureTrackerConfig.open_stereo_config)
  
  ::CameraConfig::OpenStereoConfig* temp = open_stereo_config_;
  open_stereo_config_ = NULL;
  return temp;
}
inline ::CameraConfig::OpenStereoConfig* FeatureTrackerConfig::mutable_open_stereo_config() {
  
  if (open_stereo_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::OpenStereoConfig>(GetArenaNoVirtual());
    open_stereo_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.FeatureTrackerConfig.open_stereo_config)
  return open_stereo_config_;
}
inline void FeatureTrackerConfig::set_allocated_open_stereo_config(::CameraConfig::OpenStereoConfig* open_stereo_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete open_stereo_config_;
  }
  if (open_stereo_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      open_stereo_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, open_stereo_config, submessage_arena);
    }
    
  } else {
    
  }
  open_stereo_config_ = open_stereo_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.FeatureTrackerConfig.open_stereo_config)
}

// -------------------------------------------------------------------

// OpenStereoConfig

// .TensorRTConfig.Config tensor_config = 1;
inline bool OpenStereoConfig::has_tensor_config() const {
  return this != internal_default_instance() && tensor_config_ != NULL;
}
inline const ::TensorRTConfig::Config& OpenStereoConfig::_internal_tensor_config() const {
  return *tensor_config_;
}
inline const ::TensorRTConfig::Config& OpenStereoConfig::tensor_config() const {
  const ::TensorRTConfig::Config* p = tensor_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.OpenStereoConfig.tensor_config)
  return p != NULL ? *p : *reinterpret_cast<const ::TensorRTConfig::Config*>(
      &::TensorRTConfig::_Config_default_instance_);
}
inline ::TensorRTConfig::Config* OpenStereoConfig::release_tensor_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.OpenStereoConfig.tensor_config)
  
  ::TensorRTConfig::Config* temp = tensor_config_;
  tensor_config_ = NULL;
  return temp;
}
inline ::TensorRTConfig::Config* OpenStereoConfig::mutable_tensor_config() {
  
  if (tensor_config_ == NULL) {
    auto* p = CreateMaybeMessage<::TensorRTConfig::Config>(GetArenaNoVirtual());
    tensor_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.OpenStereoConfig.tensor_config)
  return tensor_config_;
}
inline void OpenStereoConfig::set_allocated_tensor_config(::TensorRTConfig::Config* tensor_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tensor_config_);
  }
  if (tensor_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tensor_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tensor_config, submessage_arena);
    }
    
  } else {
    
  }
  tensor_config_ = tensor_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.OpenStereoConfig.tensor_config)
}

// -------------------------------------------------------------------

// KLOpticalFlowConfig

// bool enable_klopflow = 1;
inline void KLOpticalFlowConfig::clear_enable_klopflow() {
  enable_klopflow_ = false;
}
inline bool KLOpticalFlowConfig::enable_klopflow() const {
  // @@protoc_insertion_point(field_get:CameraConfig.KLOpticalFlowConfig.enable_klopflow)
  return enable_klopflow_;
}
inline void KLOpticalFlowConfig::set_enable_klopflow(bool value) {
  
  enable_klopflow_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.KLOpticalFlowConfig.enable_klopflow)
}

// bool reverse_check = 2;
inline void KLOpticalFlowConfig::clear_reverse_check() {
  reverse_check_ = false;
}
inline bool KLOpticalFlowConfig::reverse_check() const {
  // @@protoc_insertion_point(field_get:CameraConfig.KLOpticalFlowConfig.reverse_check)
  return reverse_check_;
}
inline void KLOpticalFlowConfig::set_reverse_check(bool value) {
  
  reverse_check_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.KLOpticalFlowConfig.reverse_check)
}

// double pt_err = 3;
inline void KLOpticalFlowConfig::clear_pt_err() {
  pt_err_ = 0;
}
inline double KLOpticalFlowConfig::pt_err() const {
  // @@protoc_insertion_point(field_get:CameraConfig.KLOpticalFlowConfig.pt_err)
  return pt_err_;
}
inline void KLOpticalFlowConfig::set_pt_err(double value) {
  
  pt_err_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.KLOpticalFlowConfig.pt_err)
}

// int32 min_tracked_nums = 4;
inline void KLOpticalFlowConfig::clear_min_tracked_nums() {
  min_tracked_nums_ = 0;
}
inline ::google::protobuf::int32 KLOpticalFlowConfig::min_tracked_nums() const {
  // @@protoc_insertion_point(field_get:CameraConfig.KLOpticalFlowConfig.min_tracked_nums)
  return min_tracked_nums_;
}
inline void KLOpticalFlowConfig::set_min_tracked_nums(::google::protobuf::int32 value) {
  
  min_tracked_nums_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.KLOpticalFlowConfig.min_tracked_nums)
}

// -------------------------------------------------------------------

// ORBSLAM

// -------------------------------------------------------------------

// PinholeConfig

// double fx = 1;
inline void PinholeConfig::clear_fx() {
  fx_ = 0;
}
inline double PinholeConfig::fx() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PinholeConfig.fx)
  return fx_;
}
inline void PinholeConfig::set_fx(double value) {
  
  fx_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PinholeConfig.fx)
}

// double fy = 2;
inline void PinholeConfig::clear_fy() {
  fy_ = 0;
}
inline double PinholeConfig::fy() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PinholeConfig.fy)
  return fy_;
}
inline void PinholeConfig::set_fy(double value) {
  
  fy_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PinholeConfig.fy)
}

// double cx = 3;
inline void PinholeConfig::clear_cx() {
  cx_ = 0;
}
inline double PinholeConfig::cx() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PinholeConfig.cx)
  return cx_;
}
inline void PinholeConfig::set_cx(double value) {
  
  cx_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PinholeConfig.cx)
}

// double cy = 4;
inline void PinholeConfig::clear_cy() {
  cy_ = 0;
}
inline double PinholeConfig::cy() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PinholeConfig.cy)
  return cy_;
}
inline void PinholeConfig::set_cy(double value) {
  
  cy_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PinholeConfig.cy)
}

// double k1 = 5;
inline void PinholeConfig::clear_k1() {
  k1_ = 0;
}
inline double PinholeConfig::k1() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PinholeConfig.k1)
  return k1_;
}
inline void PinholeConfig::set_k1(double value) {
  
  k1_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PinholeConfig.k1)
}

// double k2 = 6;
inline void PinholeConfig::clear_k2() {
  k2_ = 0;
}
inline double PinholeConfig::k2() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PinholeConfig.k2)
  return k2_;
}
inline void PinholeConfig::set_k2(double value) {
  
  k2_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PinholeConfig.k2)
}

// double p1 = 7;
inline void PinholeConfig::clear_p1() {
  p1_ = 0;
}
inline double PinholeConfig::p1() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PinholeConfig.p1)
  return p1_;
}
inline void PinholeConfig::set_p1(double value) {
  
  p1_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PinholeConfig.p1)
}

// double p2 = 8;
inline void PinholeConfig::clear_p2() {
  p2_ = 0;
}
inline double PinholeConfig::p2() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PinholeConfig.p2)
  return p2_;
}
inline void PinholeConfig::set_p2(double value) {
  
  p2_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PinholeConfig.p2)
}

// double focal_length = 9;
inline void PinholeConfig::clear_focal_length() {
  focal_length_ = 0;
}
inline double PinholeConfig::focal_length() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PinholeConfig.focal_length)
  return focal_length_;
}
inline void PinholeConfig::set_focal_length(double value) {
  
  focal_length_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PinholeConfig.focal_length)
}

// int32 iter_times = 10;
inline void PinholeConfig::clear_iter_times() {
  iter_times_ = 0;
}
inline ::google::protobuf::int32 PinholeConfig::iter_times() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PinholeConfig.iter_times)
  return iter_times_;
}
inline void PinholeConfig::set_iter_times(::google::protobuf::int32 value) {
  
  iter_times_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PinholeConfig.iter_times)
}

// bool enable_cv_undistort = 11;
inline void PinholeConfig::clear_enable_cv_undistort() {
  enable_cv_undistort_ = false;
}
inline bool PinholeConfig::enable_cv_undistort() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PinholeConfig.enable_cv_undistort)
  return enable_cv_undistort_;
}
inline void PinholeConfig::set_enable_cv_undistort(bool value) {
  
  enable_cv_undistort_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PinholeConfig.enable_cv_undistort)
}

// -------------------------------------------------------------------

// FishEyeConfig

// double fx = 1;
inline void FishEyeConfig::clear_fx() {
  fx_ = 0;
}
inline double FishEyeConfig::fx() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FishEyeConfig.fx)
  return fx_;
}
inline void FishEyeConfig::set_fx(double value) {
  
  fx_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FishEyeConfig.fx)
}

// double fy = 2;
inline void FishEyeConfig::clear_fy() {
  fy_ = 0;
}
inline double FishEyeConfig::fy() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FishEyeConfig.fy)
  return fy_;
}
inline void FishEyeConfig::set_fy(double value) {
  
  fy_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FishEyeConfig.fy)
}

// double cx = 3;
inline void FishEyeConfig::clear_cx() {
  cx_ = 0;
}
inline double FishEyeConfig::cx() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FishEyeConfig.cx)
  return cx_;
}
inline void FishEyeConfig::set_cx(double value) {
  
  cx_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FishEyeConfig.cx)
}

// double cy = 4;
inline void FishEyeConfig::clear_cy() {
  cy_ = 0;
}
inline double FishEyeConfig::cy() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FishEyeConfig.cy)
  return cy_;
}
inline void FishEyeConfig::set_cy(double value) {
  
  cy_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FishEyeConfig.cy)
}

// double k1 = 5;
inline void FishEyeConfig::clear_k1() {
  k1_ = 0;
}
inline double FishEyeConfig::k1() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FishEyeConfig.k1)
  return k1_;
}
inline void FishEyeConfig::set_k1(double value) {
  
  k1_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FishEyeConfig.k1)
}

// double k2 = 6;
inline void FishEyeConfig::clear_k2() {
  k2_ = 0;
}
inline double FishEyeConfig::k2() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FishEyeConfig.k2)
  return k2_;
}
inline void FishEyeConfig::set_k2(double value) {
  
  k2_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FishEyeConfig.k2)
}

// double k3 = 7;
inline void FishEyeConfig::clear_k3() {
  k3_ = 0;
}
inline double FishEyeConfig::k3() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FishEyeConfig.k3)
  return k3_;
}
inline void FishEyeConfig::set_k3(double value) {
  
  k3_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FishEyeConfig.k3)
}

// double k4 = 8;
inline void FishEyeConfig::clear_k4() {
  k4_ = 0;
}
inline double FishEyeConfig::k4() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FishEyeConfig.k4)
  return k4_;
}
inline void FishEyeConfig::set_k4(double value) {
  
  k4_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FishEyeConfig.k4)
}

// double focal_length = 9;
inline void FishEyeConfig::clear_focal_length() {
  focal_length_ = 0;
}
inline double FishEyeConfig::focal_length() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FishEyeConfig.focal_length)
  return focal_length_;
}
inline void FishEyeConfig::set_focal_length(double value) {
  
  focal_length_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FishEyeConfig.focal_length)
}

// int32 iter_times = 10;
inline void FishEyeConfig::clear_iter_times() {
  iter_times_ = 0;
}
inline ::google::protobuf::int32 FishEyeConfig::iter_times() const {
  // @@protoc_insertion_point(field_get:CameraConfig.FishEyeConfig.iter_times)
  return iter_times_;
}
inline void FishEyeConfig::set_iter_times(::google::protobuf::int32 value) {
  
  iter_times_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.FishEyeConfig.iter_times)
}

// -------------------------------------------------------------------

// CameraModel

// .CameraConfig.CameraModel.CameraType type = 1;
inline void CameraModel::clear_type() {
  type_ = 0;
}
inline ::CameraConfig::CameraModel_CameraType CameraModel::type() const {
  // @@protoc_insertion_point(field_get:CameraConfig.CameraModel.type)
  return static_cast< ::CameraConfig::CameraModel_CameraType >(type_);
}
inline void CameraModel::set_type(::CameraConfig::CameraModel_CameraType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.CameraModel.type)
}

// .CameraConfig.PinholeConfig pinhole_config = 2;
inline bool CameraModel::has_pinhole_config() const {
  return this != internal_default_instance() && pinhole_config_ != NULL;
}
inline void CameraModel::clear_pinhole_config() {
  if (GetArenaNoVirtual() == NULL && pinhole_config_ != NULL) {
    delete pinhole_config_;
  }
  pinhole_config_ = NULL;
}
inline const ::CameraConfig::PinholeConfig& CameraModel::_internal_pinhole_config() const {
  return *pinhole_config_;
}
inline const ::CameraConfig::PinholeConfig& CameraModel::pinhole_config() const {
  const ::CameraConfig::PinholeConfig* p = pinhole_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.CameraModel.pinhole_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::PinholeConfig*>(
      &::CameraConfig::_PinholeConfig_default_instance_);
}
inline ::CameraConfig::PinholeConfig* CameraModel::release_pinhole_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.CameraModel.pinhole_config)
  
  ::CameraConfig::PinholeConfig* temp = pinhole_config_;
  pinhole_config_ = NULL;
  return temp;
}
inline ::CameraConfig::PinholeConfig* CameraModel::mutable_pinhole_config() {
  
  if (pinhole_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::PinholeConfig>(GetArenaNoVirtual());
    pinhole_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.CameraModel.pinhole_config)
  return pinhole_config_;
}
inline void CameraModel::set_allocated_pinhole_config(::CameraConfig::PinholeConfig* pinhole_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pinhole_config_;
  }
  if (pinhole_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pinhole_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pinhole_config, submessage_arena);
    }
    
  } else {
    
  }
  pinhole_config_ = pinhole_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.CameraModel.pinhole_config)
}

// .CameraConfig.FishEyeConfig fish_eye_config = 3;
inline bool CameraModel::has_fish_eye_config() const {
  return this != internal_default_instance() && fish_eye_config_ != NULL;
}
inline void CameraModel::clear_fish_eye_config() {
  if (GetArenaNoVirtual() == NULL && fish_eye_config_ != NULL) {
    delete fish_eye_config_;
  }
  fish_eye_config_ = NULL;
}
inline const ::CameraConfig::FishEyeConfig& CameraModel::_internal_fish_eye_config() const {
  return *fish_eye_config_;
}
inline const ::CameraConfig::FishEyeConfig& CameraModel::fish_eye_config() const {
  const ::CameraConfig::FishEyeConfig* p = fish_eye_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.CameraModel.fish_eye_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::FishEyeConfig*>(
      &::CameraConfig::_FishEyeConfig_default_instance_);
}
inline ::CameraConfig::FishEyeConfig* CameraModel::release_fish_eye_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.CameraModel.fish_eye_config)
  
  ::CameraConfig::FishEyeConfig* temp = fish_eye_config_;
  fish_eye_config_ = NULL;
  return temp;
}
inline ::CameraConfig::FishEyeConfig* CameraModel::mutable_fish_eye_config() {
  
  if (fish_eye_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::FishEyeConfig>(GetArenaNoVirtual());
    fish_eye_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.CameraModel.fish_eye_config)
  return fish_eye_config_;
}
inline void CameraModel::set_allocated_fish_eye_config(::CameraConfig::FishEyeConfig* fish_eye_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fish_eye_config_;
  }
  if (fish_eye_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fish_eye_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fish_eye_config, submessage_arena);
    }
    
  } else {
    
  }
  fish_eye_config_ = fish_eye_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.CameraModel.fish_eye_config)
}

// -------------------------------------------------------------------

// SFMConfig

// .CameraConfig.CameraModel camera_model = 1;
inline bool SFMConfig::has_camera_model() const {
  return this != internal_default_instance() && camera_model_ != NULL;
}
inline void SFMConfig::clear_camera_model() {
  if (GetArenaNoVirtual() == NULL && camera_model_ != NULL) {
    delete camera_model_;
  }
  camera_model_ = NULL;
}
inline const ::CameraConfig::CameraModel& SFMConfig::_internal_camera_model() const {
  return *camera_model_;
}
inline const ::CameraConfig::CameraModel& SFMConfig::camera_model() const {
  const ::CameraConfig::CameraModel* p = camera_model_;
  // @@protoc_insertion_point(field_get:CameraConfig.SFMConfig.camera_model)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::CameraModel*>(
      &::CameraConfig::_CameraModel_default_instance_);
}
inline ::CameraConfig::CameraModel* SFMConfig::release_camera_model() {
  // @@protoc_insertion_point(field_release:CameraConfig.SFMConfig.camera_model)
  
  ::CameraConfig::CameraModel* temp = camera_model_;
  camera_model_ = NULL;
  return temp;
}
inline ::CameraConfig::CameraModel* SFMConfig::mutable_camera_model() {
  
  if (camera_model_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::CameraModel>(GetArenaNoVirtual());
    camera_model_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.SFMConfig.camera_model)
  return camera_model_;
}
inline void SFMConfig::set_allocated_camera_model(::CameraConfig::CameraModel* camera_model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete camera_model_;
  }
  if (camera_model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      camera_model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, camera_model, submessage_arena);
    }
    
  } else {
    
  }
  camera_model_ = camera_model;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.SFMConfig.camera_model)
}

// .CameraConfig.PnpSolverConfig pnp_solver = 2;
inline bool SFMConfig::has_pnp_solver() const {
  return this != internal_default_instance() && pnp_solver_ != NULL;
}
inline void SFMConfig::clear_pnp_solver() {
  if (GetArenaNoVirtual() == NULL && pnp_solver_ != NULL) {
    delete pnp_solver_;
  }
  pnp_solver_ = NULL;
}
inline const ::CameraConfig::PnpSolverConfig& SFMConfig::_internal_pnp_solver() const {
  return *pnp_solver_;
}
inline const ::CameraConfig::PnpSolverConfig& SFMConfig::pnp_solver() const {
  const ::CameraConfig::PnpSolverConfig* p = pnp_solver_;
  // @@protoc_insertion_point(field_get:CameraConfig.SFMConfig.pnp_solver)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::PnpSolverConfig*>(
      &::CameraConfig::_PnpSolverConfig_default_instance_);
}
inline ::CameraConfig::PnpSolverConfig* SFMConfig::release_pnp_solver() {
  // @@protoc_insertion_point(field_release:CameraConfig.SFMConfig.pnp_solver)
  
  ::CameraConfig::PnpSolverConfig* temp = pnp_solver_;
  pnp_solver_ = NULL;
  return temp;
}
inline ::CameraConfig::PnpSolverConfig* SFMConfig::mutable_pnp_solver() {
  
  if (pnp_solver_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::PnpSolverConfig>(GetArenaNoVirtual());
    pnp_solver_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.SFMConfig.pnp_solver)
  return pnp_solver_;
}
inline void SFMConfig::set_allocated_pnp_solver(::CameraConfig::PnpSolverConfig* pnp_solver) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pnp_solver_;
  }
  if (pnp_solver) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pnp_solver = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pnp_solver, submessage_arena);
    }
    
  } else {
    
  }
  pnp_solver_ = pnp_solver;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.SFMConfig.pnp_solver)
}

// .CameraConfig.FeatureConfig feature_config = 3;
inline bool SFMConfig::has_feature_config() const {
  return this != internal_default_instance() && feature_config_ != NULL;
}
inline void SFMConfig::clear_feature_config() {
  if (GetArenaNoVirtual() == NULL && feature_config_ != NULL) {
    delete feature_config_;
  }
  feature_config_ = NULL;
}
inline const ::CameraConfig::FeatureConfig& SFMConfig::_internal_feature_config() const {
  return *feature_config_;
}
inline const ::CameraConfig::FeatureConfig& SFMConfig::feature_config() const {
  const ::CameraConfig::FeatureConfig* p = feature_config_;
  // @@protoc_insertion_point(field_get:CameraConfig.SFMConfig.feature_config)
  return p != NULL ? *p : *reinterpret_cast<const ::CameraConfig::FeatureConfig*>(
      &::CameraConfig::_FeatureConfig_default_instance_);
}
inline ::CameraConfig::FeatureConfig* SFMConfig::release_feature_config() {
  // @@protoc_insertion_point(field_release:CameraConfig.SFMConfig.feature_config)
  
  ::CameraConfig::FeatureConfig* temp = feature_config_;
  feature_config_ = NULL;
  return temp;
}
inline ::CameraConfig::FeatureConfig* SFMConfig::mutable_feature_config() {
  
  if (feature_config_ == NULL) {
    auto* p = CreateMaybeMessage<::CameraConfig::FeatureConfig>(GetArenaNoVirtual());
    feature_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:CameraConfig.SFMConfig.feature_config)
  return feature_config_;
}
inline void SFMConfig::set_allocated_feature_config(::CameraConfig::FeatureConfig* feature_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete feature_config_;
  }
  if (feature_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature_config, submessage_arena);
    }
    
  } else {
    
  }
  feature_config_ = feature_config;
  // @@protoc_insertion_point(field_set_allocated:CameraConfig.SFMConfig.feature_config)
}

// bool enable_cv_p2p = 4;
inline void SFMConfig::clear_enable_cv_p2p() {
  enable_cv_p2p_ = false;
}
inline bool SFMConfig::enable_cv_p2p() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SFMConfig.enable_cv_p2p)
  return enable_cv_p2p_;
}
inline void SFMConfig::set_enable_cv_p2p(bool value) {
  
  enable_cv_p2p_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SFMConfig.enable_cv_p2p)
}

// int32 ransac_iterations = 5;
inline void SFMConfig::clear_ransac_iterations() {
  ransac_iterations_ = 0;
}
inline ::google::protobuf::int32 SFMConfig::ransac_iterations() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SFMConfig.ransac_iterations)
  return ransac_iterations_;
}
inline void SFMConfig::set_ransac_iterations(::google::protobuf::int32 value) {
  
  ransac_iterations_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SFMConfig.ransac_iterations)
}

// double reproj_err_th = 6;
inline void SFMConfig::clear_reproj_err_th() {
  reproj_err_th_ = 0;
}
inline double SFMConfig::reproj_err_th() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SFMConfig.reproj_err_th)
  return reproj_err_th_;
}
inline void SFMConfig::set_reproj_err_th(double value) {
  
  reproj_err_th_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SFMConfig.reproj_err_th)
}

// double sigma = 7;
inline void SFMConfig::clear_sigma() {
  sigma_ = 0;
}
inline double SFMConfig::sigma() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SFMConfig.sigma)
  return sigma_;
}
inline void SFMConfig::set_sigma(double value) {
  
  sigma_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SFMConfig.sigma)
}

// .CameraConfig.SFMConfig.DecomposeHMethod decompose_H_method = 8;
inline void SFMConfig::clear_decompose_h_method() {
  decompose_h_method_ = 0;
}
inline ::CameraConfig::SFMConfig_DecomposeHMethod SFMConfig::decompose_h_method() const {
  // @@protoc_insertion_point(field_get:CameraConfig.SFMConfig.decompose_H_method)
  return static_cast< ::CameraConfig::SFMConfig_DecomposeHMethod >(decompose_h_method_);
}
inline void SFMConfig::set_decompose_h_method(::CameraConfig::SFMConfig_DecomposeHMethod value) {
  
  decompose_h_method_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.SFMConfig.decompose_H_method)
}

// -------------------------------------------------------------------

// PnpSolverConfig

// bool enable_cv_pnp = 1;
inline void PnpSolverConfig::clear_enable_cv_pnp() {
  enable_cv_pnp_ = false;
}
inline bool PnpSolverConfig::enable_cv_pnp() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PnpSolverConfig.enable_cv_pnp)
  return enable_cv_pnp_;
}
inline void PnpSolverConfig::set_enable_cv_pnp(bool value) {
  
  enable_cv_pnp_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PnpSolverConfig.enable_cv_pnp)
}

// .CameraConfig.PnpSolverConfig.PnpSolveMethod pnp_solve_method = 2;
inline void PnpSolverConfig::clear_pnp_solve_method() {
  pnp_solve_method_ = 0;
}
inline ::CameraConfig::PnpSolverConfig_PnpSolveMethod PnpSolverConfig::pnp_solve_method() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PnpSolverConfig.pnp_solve_method)
  return static_cast< ::CameraConfig::PnpSolverConfig_PnpSolveMethod >(pnp_solve_method_);
}
inline void PnpSolverConfig::set_pnp_solve_method(::CameraConfig::PnpSolverConfig_PnpSolveMethod value) {
  
  pnp_solve_method_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PnpSolverConfig.pnp_solve_method)
}

// .CameraConfig.PnpSolverConfig.PnpCvMethod pnp_cv_method = 3;
inline void PnpSolverConfig::clear_pnp_cv_method() {
  pnp_cv_method_ = 0;
}
inline ::CameraConfig::PnpSolverConfig_PnpCvMethod PnpSolverConfig::pnp_cv_method() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PnpSolverConfig.pnp_cv_method)
  return static_cast< ::CameraConfig::PnpSolverConfig_PnpCvMethod >(pnp_cv_method_);
}
inline void PnpSolverConfig::set_pnp_cv_method(::CameraConfig::PnpSolverConfig_PnpCvMethod value) {
  
  pnp_cv_method_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PnpSolverConfig.pnp_cv_method)
}

// int32 max_iterations = 4;
inline void PnpSolverConfig::clear_max_iterations() {
  max_iterations_ = 0;
}
inline ::google::protobuf::int32 PnpSolverConfig::max_iterations() const {
  // @@protoc_insertion_point(field_get:CameraConfig.PnpSolverConfig.max_iterations)
  return max_iterations_;
}
inline void PnpSolverConfig::set_max_iterations(::google::protobuf::int32 value) {
  
  max_iterations_ = value;
  // @@protoc_insertion_point(field_set:CameraConfig.PnpSolverConfig.max_iterations)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace CameraConfig

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::CameraConfig::FeatureTrackerConfig_TrackerMothod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::FeatureTrackerConfig_TrackerMothod>() {
  return ::CameraConfig::FeatureTrackerConfig_TrackerMothod_descriptor();
}
template <> struct is_proto_enum< ::CameraConfig::CameraModel_CameraType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::CameraModel_CameraType>() {
  return ::CameraConfig::CameraModel_CameraType_descriptor();
}
template <> struct is_proto_enum< ::CameraConfig::SFMConfig_DecomposeHMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::SFMConfig_DecomposeHMethod>() {
  return ::CameraConfig::SFMConfig_DecomposeHMethod_descriptor();
}
template <> struct is_proto_enum< ::CameraConfig::PnpSolverConfig_PnpSolveMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::PnpSolverConfig_PnpSolveMethod>() {
  return ::CameraConfig::PnpSolverConfig_PnpSolveMethod_descriptor();
}
template <> struct is_proto_enum< ::CameraConfig::PnpSolverConfig_PnpCvMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::PnpSolverConfig_PnpCvMethod>() {
  return ::CameraConfig::PnpSolverConfig_PnpCvMethod_descriptor();
}
template <> struct is_proto_enum< ::CameraConfig::MatcherType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::MatcherType>() {
  return ::CameraConfig::MatcherType_descriptor();
}
template <> struct is_proto_enum< ::CameraConfig::FeatureType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::FeatureType>() {
  return ::CameraConfig::FeatureType_descriptor();
}
template <> struct is_proto_enum< ::CameraConfig::DescriptorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraConfig::DescriptorType>() {
  return ::CameraConfig::DescriptorType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_camera_2eproto
